import BlogPost from "../../../components/blog_post";

export const meta = {
  title: "Tech Debt, or Tech Loan?",
  date: "2020-12-22",
  tags: ["Technical Debt", "Code Design"],
  category: "development",
};

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

If you're interested in **Technical Debt**, hats off to you, because you probably care about the code you write, or
read. If this term is new to you, Wikipedia offers a great overview about [what Technical Debt
is](https://en.wikipedia.org/wiki/Technical_debt) and what are its common causes:

> "Technical Debt reflects the implied cost of additional rework caused by choosing an easy (limited) solution now,
> instead of using a better approach that would take longer"

As it states, Technical Debt is a trade-off, a choice we make as developers. Sometimes we are (or feel) pushed to make
these trade-offs. Sometimes it's our own decision. We can't always prevent them, so we need to learn how to manage them.

## Design flaws

While it's not trivial to pin-point what pieces of code should be considered as Technical Debt, there's a general
agreement that it's related to **software design**. Personally, I've seen 3 major categories of code, in regard to
software design:

- **Well designed code**
  This includes flexible, tested, documented code, easy to read, understand, extend, modify or remove.
  Smaller libraries can easily reach this level of code design, while large applications might contain only parts of such
  code.

- **Good enough code**
  Code that lacks some of the aspects of well designed code, due to complex requirements.
  This usually applies to bigger libraries and applications, which usually contain a considerable amount of decent code,
  but not ideal.

- **Poorly designed code**
  This includes a wide variety of symptoms that you've probably encountered by now:
  - opaque code, which is difficult to read and understand what is does;
  - rigid code, when adding or extending its functionality requires a complete re-write;
  - fragile code, when tiny changes break unrelated parts of code;
  - no associated tests, which makes the code impossible to refactor, in order to fix the problems above;
  - scary code, which we don't change or even touch, because of the fear of not breaking something.

When we get to **Scary Code**, our code will begin to rot, and I think we can agree that we have a huge problem.

## Why do we write poorly designed code?

Nobody writes "bad code" on purpose. There are various reasons why we do this, some understandable, others not so much:

### Ignorance

The lack of experience could render us unable to identify the potential design flaws, especially during the first years
of experience. We've all been through this phase, and will probably find ourselves again and again when dealing with new
challenges.

This scenario [doesn't really fall into the category of Technical
Debt](https://sites.google.com/site/unclebobconsultingllc/a-mess-is-not-a-technical-debt) as there's no actual
trade-off. To talk about a debt, we have to choose a quick & dirty solution, over another more robust approach.

### Negligence

Sometimes we simply don't care. We are aware that we've chosen a quick & dirty solution, we acknowledge that it will
have consequences later on, but we only care about the present.

This is a toxic attitude that causes Technical Debt, which would lead to [broken
windows](https://blog.codinghorror.com/the-broken-window-theory/), and eventually could cause the project to get out of
control if not addressed.

### Deprioritization

Sometimes we do care. We understand the trade-offs, and we intend to fix them as soon as possible, that why we:

- create an issue in our git repository;
- create a task in our issue tracker;
- mark it as a `@todo` comment;
- write it down in our notebook, post-it or whiteboard.

However, none of the above helps if we don't actually fix the problem. If the trade-off "works", we might be forced to
move on to other, more important tasks or features.

Eventually, this would also lead to Technical Debt, and because we did care, we could consider that "we did our part",
and now it's time for somebody else to prioritize the refactoring. I believe this not true.

## The technical nature of the debt

It's true that Technical Debt has a huge impact on the product as well, not only on the development of it. But we, as
developers, need to understand that we are the ones that made that choice.

There's a reason why it's called "Technical" Debt. Even if the cause is not technical, the code which includes the
Technical Debt is written by us, developers, and we are the only ones that are able to "pay the debt".

We need to be responsible for the code that we write. We need to do whatever is necessary to fix the trade-offs that we
know will become big problems later on.

## Introducing Technical Loan

The problem with **debt** is not the trade-off itself, but the **interest** that we have to pay over and over.

A **loan**, on the other hand, implies the same trade-off, but **without any interest**. Think of it like borrowing
money from a friend, and returning it next month.

We can apply the same mindset to technical trade-offs: as soon as we are aware of a trade-off, that could turn into
technical debt, we should address it:

- discuss it with the team during our next meeting;
- don't start new features before fixing the outstanding trade-off;
- consider it a priority and plan it as soon as possible, ideally during the next sprint.

<!-- Of course, not all loans are equal. Some of them could be returned when needed, while others are critical to be returned quickly.

### Safe loans

I would include in this category

### Critical loans -->

<!-- Depending on your manager or client, there are different ways to handle it:

- If you're dealing with a cerebral, tech-savvy person, we should be able to address the problems freely.
- If you're dealing with a pushy person, learn to push-back. Tell them "We won't be able to make that deadline, we need to remove this feature". Always be sincere, but polite.
- If you're dealing with a non-technical person, you should avoid terms like "refactor" or "rewrite". Tell them that "We need to make some changes to accommodate (the following) new features".
- If you're unlucky and you're dealing with difficult clients or managers, just include the refactoring in a related task or issue. As long as they don't know (and honestly don't even care), and new features are also released, everybody's happy.
- If they ask you "Why does it take so long?", explain that "We had to take some shortcuts to meet the deadline and we need to make some changes".
- If all of the above fails, you can disguise the refactoring under some task that includes "security" or "performance", depending on what might tickle your manager or client. -->

## Take loans. Avoid debts.

Taking shortcuts in software development is unavoidable. It's also a powerful tool to have around when needed. However, we must to
understand that any shortcut is a trade-off, and all trade-offs have consequences.

Whenever we have to deal with a **debt**, we pay constant **interest**. The bigger the debt, the higher the interest. The more we avoid paying the debt, the more interest accumulates.
The only way to get rid of the interest is to pay the debt.

We can avoid debt, if we make a **loan** instead. No interest to pay, but we have to return the loan as soon as
possible.
