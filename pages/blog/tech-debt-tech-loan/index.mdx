import BlogPost from "../../../components/blog_post";

export const meta = {
  title: "Tech Debt, or Tech Loan?",
  date: "2020-12-22",
  tags: ["Technical Debt", "Code Design"],
  category: "development",
};

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

If you're interested in **Technical Debt**, hats off to you, because you probably care about the code you write, or
read. In case this term is new to you, Wikipedia offers a great overview about [what Technical Debt
is](https://en.wikipedia.org/wiki/Technical_debt) and what are its common causes:

> "Technical Debt reflects the implied cost of additional rework caused by choosing an easy (but limited) solution now,
> instead of using a better approach that would take longer"

As it states, Technical Debt is a trade-off, a choice we make as developers. Sometimes we are (or feel) pushed to make
these trade-offs. Sometimes it's our own decision. We can't always prevent them, so we need to learn how to manage them.

## Design flaws

While it's not trivial to pin-point what pieces of code should be considered as Technical Debt, there's a general
agreement that it's related to **software design**. Personally, I've seen 3 major categories of code, in regard to
software design:

- **Well designed code**  
  This includes flexible, tested, documented code, easy to read, understand, extend, modify or remove.
  Smaller libraries can easily reach this level of code design, while large applications might contain only parts of such
  code.

- **Good enough code**  
  Code that lacks some of the aspects of well designed code, due to complex requirements.
  This usually applies to bigger libraries and applications, which usually contain a considerable amount of decent code,
  but not ideal.

- **Poorly designed code**  
  This includes a wide variety of symptoms that you've probably encountered by now:
  - opaque code, which is difficult to read and understand what is does;
  - rigid code, when adding or extending its functionality requires a complete re-write;
  - fragile code, when tiny changes break unrelated parts of code;
  - no associated tests, which makes the code impossible to refactor, in order to fix the problems above;
  - scary code, which we don't change or even touch, because of the fear of not breaking something.

We should all aim for writting well designed code, even if we are only able to make it good enough.

It's the poorly and badly designed code that we should stay away from, because it has a tendency to [rot](https://en.wikipedia.org/wiki/Software_rot) and once it does that, the rot will spread, which will cause huge problems on the long run.

## Why do we write poorly designed code?

Nobody writes "bad code" on purpose. There are various reasons why we do this, some understandable, others not so much:

### Ignorance

The lack of experience could render us unable to identify the potential design flaws, especially during the first years
of experience. We've all been through this phase, and will probably find ourselves again and again when dealing with new
challenges.

This scenario [doesn't really fall into the category of Technical
Debt](https://sites.google.com/site/unclebobconsultingllc/a-mess-is-not-a-technical-debt) as there's no actual
trade-off. To talk about a debt, we have to choose a quick & dirty solution, over another more robust approach.

### Negligence

Sometimes we simply don't care. We are aware that we've chosen a quick & dirty solution, we acknowledge that it will
have consequences later on, but we only care about the present.

This is a toxic attitude that causes Technical Debt, which would lead to [broken
windows](https://blog.codinghorror.com/the-broken-window-theory/), and eventually could cause the project to get out of
control if not addressed.

### Deprioritization

Sometimes we do care. We understand the trade-offs, and we intend to fix them as soon as possible. We might even:

- create an issue in our git repository;
- create a task in our issue tracker;
- mark it as a `@todo` comment;
- write it down in our notebook or whiteboard.

However, none of the above helps if we don't actually fix the problem. If the trade-off "works", we might be forced to
move on to other, more important tasks or features.

Eventually, this would also lead to Technical Debt, but because we acknowledged the problem, we could consider that "we did our part",
and now it's time for somebody else to prioritize the refactoring.

Acknowledging a problem, but not fixing it, is still a problem.

## The technical nature of the debt

It's true that Technical Debt has a huge impact on the product as well, not only on the development of it. But we, as
developers, need to understand that we are the ones that made that choice.

There's a reason why it's called **Technical** Debt. Even if the cause is not technical, the code which includes the
Technical Debt is written by us, developers, and we are the only ones that are able to "pay the debt".

We need to be responsible for the code that we write. We need to do whatever is necessary to fix the trade-offs that we
know will become big problems later on.

## Introducing Technical Loan

The problem with **debt** is not the trade-off itself, but the **interest** that we have to pay over and over.

A **loan**, on the other hand, implies the same trade-off, but **without any interest**. Think of it like borrowing
money from a friend for a short period of time. You'll still need to return the money, but you don't pay any additional interest.

We can apply the same mindset to technical trade-offs: as soon as we are aware of a trade-off, that could turn into
technical debt, we should address it right away:

- discuss it with the team during our next meeting;
- don't start new features before fixing the outstanding trade-off;
- consider it a priority and plan it as soon as possible, ideally during the next sprint.

## Take loans. Avoid debts.

Taking shortcuts in software development is unavoidable. It's also a powerful tool to have around when needed. However, we must to
understand that any shortcut is a trade-off, and all trade-offs have consequences.

Whenever we have to deal with a **debt**, we pay constant **interest**. The bigger the debt, the higher the interest. The more we avoid paying the debt, the more interest accumulates.
The only way to get rid of the interest is to pay the debt.

We can avoid debt, if we make a **loan** instead. No interest to pay, but we have to return the loan as soon as
possible.
