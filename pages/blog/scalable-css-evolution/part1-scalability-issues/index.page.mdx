import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { TOC } from "../toc";

import { meta } from "./meta";
export { meta } from "./meta";

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={1} />

Before going any further to discuss the solutions, we must understand the problems. Generally speaking, when we talk about software scalability, we look at **how something behaves when we greatly increase its size**.

To give an example, if a certain problem increases proportionally with the size of the code, it means that we have a **scalability issue**. Even an insignificant detail such as _using `!important`_ could become a huge problem when we consider a several years long project with a team of several developers.

Each of us has their own definition of _"what is a large project"_. From my own experience, CSS scalability problems become visible when working with:

- projects that span over more than 6 months;
- larger teams, usually more than 3 developers;

<br />

So, let's take a look at some of the most concearning problems when we talk about CSS scalability:

1. [Zombie code](#zombie-code)
2. [Naming collisions](#naming-collisions)
3. [Specificity wars](#specificity-wars)
4. [Source code precedence](#source-code-precedence)
5. [Selector duplication](#selector-duplication)
6. [Cumbersome media queries (poate il punem impreuna cu Selector duplication)](#cumbersome-media-queries)
7. [Implicit dependencies](#implicit-dependencies)
8. [Shared design tokens](#shared-design-tokens)
9. [Lack of type-safety](#lack-of-type-safety)

## Zombie code

CSS code will usually only increase in size. Developers avoid deleting unused CSS code because it's impossible to detect if certain selectors are needed anymore, so they could be safely removed.

- removing temporary markup, but forgetting to delete the associated styles;
- removing a reusable concept, but avoid deleting the selectors from a global styles file, because of the fear that they could be used somewhere else;

<br />

<SideBySide left={{lang: "HTML", file: "page.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html
<p class="promo">
  <h2>Promo text...</h2>
</p>

<!-- This will get removed at some point... -->
<button class="promo_link">
  Check this out
</button>
```

```css
.promo {
  font-size: 1.5em;
}

/* ... but it associated styles would be probably left in the codebase */
.promo_link {
  color: blue;
}
```

</SideBySide>

This means that we'll surely ship more CSS code than is actually needed, slowing down the page load and making the code base less manageable.

This happens because CSS cannot be statically analyzed. Also, there is no tools that could safely tell us which CSS selectors are not used. https://css-tricks.com/how-do-you-remove-unused-css-from-a-site/

## Naming collisions

Abstract and reusable class names usually contain common nouns, like `.modal`, `.button`, `.overlay`, etc. If we include an external file that defines the same class names they could get overwritten, depending on which file is included last.

CSS lacks any namespace concept, so it doesn't help us to prevent style overwritting. A common solution to this problem is to add a project specific **prefix**, for instance `.abc-overlay`. Third party libraries usually take this.

However, this does not guarantee unique names. When dealing with large and multiple files, how could we be sure that nobody else added the class `.abc-heading-large`? We could search the entire code base to see if we find such a already class defined.

Not to mention that we might deal with **dynamic** class names, computed using some custom logic that prevents searching for a string like `.abc-heading-large`:

```js
const classname = `abc-heading-${isPromo ? "large" : "small"}`;
```

However, we could include stylesheets written by a different team. In this case, making sure that we don't have any collitions can become quite a challenge.

But no stress, we can solve any such issues using a **higher specificity**, right?

## Specificity wars

One way to avoid naming collitions is to increase the "strength of a selector", or the so called [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity). This definitely works on the short run, but it could really get out of control:

```css
/* we start with a simple generic "title" class */
.title {
}

/* we use the same class name, for a specific "product" component */
.product .title {
}

/* but we also have a modified "discounted" variation */
.product .title.discount {
}

/* also, there's a different variation inside the "promo" section */
#promo .product .title.discount {
}

/* not to mention the "dark theme" styles */
.dark-theme #promo .product .title.discount {
}

/* to avoid specificity problems, we'll end up using "!important" */
.special.title {
  color: blue !important;
}
```

Once we start relying on specificity, we will find it harder and harder to overwrite styles. Eventually, the only way to define new styles will be using `!important`. Once we reach that scenario, the code base will be almost impossible to extend. I can tell you this based on my very own experience.

## Source code precedence

Ok, let's say that we stick to a low specificity and that we manage somehow to avoid naming collisions. One thing to keep in mind is that when specificity is the same, source code order takes place: _styles declared later always win_.

Consider the following trivial example:

<!-- prettier-ignore-start -->
```html
<!-- page.html -->
<p class="red blue"> Red or Blue? </p>
```

```css
/* styles.css */
.blue { color: blue; }
.red { color: red; }
```
<!-- prettier-ignore-end -->

If we look at the `.html` file, we might think that the text will be have the `.blue` class applied. But it's not the order of CSS classes that we apply to the HTML element that matters. It's the order of the styles defined in the CSS stylesheets.

When looking at the `.css` file, we see that `.red` is defined later, which means that its styles will win.

Now, let's imagine how could this affect us on a large project:

- consider that you're adding a new class to override some styles, but it doesn't work, because other styles defined later in code take precedence;
- consider breaking the styles of a page only because we refactored our stylesheet by changing the order of some styles;
- working with dynamically loaded stylesheets could become a real nightmare, because styles resolution will become un-deterministic.

## Selector duplication

When using plain CSS, defining any pseudo class, pseudo element, or media query will force us to duplicate the CSS selector:

<!-- prettier-ignore-start -->
```css
.product_title { }

.product_title:hover { }
.product_title::after { }

@media (min-width: 768px) {
  .product_title { }
  .product_title::after { }
}
```
<!-- prettier-ignore-end -->

Duplicating selectors during development is not a real scalability problem, more of an annoying issue. But during various refactorings such as renaming, moving, or deleting, dealing with a multitude of duplicated classes could become tricky.

Any feature that impedes code maintenance could potentially become a scalability concern.

## Cumbersome media queries

An even bigger problem we'll face is when we have to deal with responsive web pages and media queries. There are 2 different ways we can group our styles: **by media query** or **by CSS selector**:

<br />

<!-- prettier-ignore-start -->

<SideBySide left={{lang: "CSS", file: "Group by media query"}}  right={{lang: "CSS", file: "Group by CSS selector"}}>

```css
/* line 23 */
.product { }
.product_title { }
.product_body { }

...

/* line 163 */
@media (min-width: 768px) {
  .product { }
  .product_title { }
  .product_body { }
}

...

/* line 390 */
@media (min-width: 1280px) {
  .product { }
  .product_title { }
  .product_body { }
}
```

```css
.product { }
@media (min-width: 768px) {
  .product { }
}
@media (min-width: 1280px) {
  .product { }
}

.product_title { }
@media (min-width: 768px) {
  .product_title { }
}
@media (min-width: 1280px) {
  .product_title { }
}

.product_body { }
@media (min-width: 768px) {
  .product_body { }
}
@media (min-width: 1280px) {
  .product_body { }
}
```

</SideBySide>

<!-- prettier-ignore-end -->

<br />

<Subheading>Groupping by media query</Subheading>

As developers, we usually try to avoid code duplication as much as possible. Groupping by media query defines the media queries only once, so it's probably a more approach appealling. The downside is that it's very difficult to read, understand, and maintain such a code. The styles for a single element could be split in different parts of the file. **Figuring out which are all the styles that apply to a particular selector becomes a real scalability problem.**

<Subheading>Groupping by CSS selector</Subheading>

To enable an easier understanding of the code, which is crucial when we think about scaling, we could group the styles by CSS selectors. Using this approach, we don't have to search the whole file to figure out which styles apply to a certain selector. **The downside is that there's more boilerplate and the output is larger.**

<!-- ## Cumbersome design tokens sharing

CSS custom properties commonly known as "CSS variables" are very useful to avoid certain types of code duplication, such as colors, breakpoints, fonts sizes, spacing values, etc. These values are usually called **design tokens** and they're required in design systems, but also very useful in any application that doesn't use a strict system.

Extracting design tokens as variables provides easy reusability and maintainability. They are easy to change, because there's a single source of truth.

Also, theming becomes much easier to implement. If we think about dark mode, which is pretty popular nowadays, theming is not a scarce feature anymore. -->

## Implicit dependencies

## Shared design tokens

-> adaptive layouts, access breakpoints in logic

## Lack of type-safety

Before using TypeScript or other strongly typed languages, I never thought about the highly dynamic nature of CSS. I thought that there isn't any other way, so I got used to it.

But after I started using statically typed languages, I've begun to feel the lack of type-safety when authoring and maintaining either plain CSS, accompanied by preprocessors, or CSS modules:

- **Missing a "go to definition" or "find references"** feature, which is very useful in debugging, to determine which styles apply to a particular element, or where is a paticular class name applied. Instead, we must use copy the class name from the markup and search for it in the stylesheet, or vice-versa.
- **Refactorings are not safe** because the tooling doesn't help highlighting any syntax errors when renaming class names, or removing them. This alone will lead to developers being afraid to touch or modify any existing code, which could ultimately lead to [code rot](https://en.wikipedia.org/wiki/Software_rot).

<Note>
  It's important to keep in mind that none of the previously mentioned concerns
  are a problem if we work alone on a small project. But they will become real
  problems when working on larger projects, together with other developers.
</Note>

---

In part 2 of this series we'll cover **preprocessors**.
