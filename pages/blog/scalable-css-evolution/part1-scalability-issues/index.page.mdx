import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide, Side} from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { TOC, LinkTo } from "../toc";

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 1;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

## What is "scalability"?

Generally speaking, when we talk about _software scalability_, we look at **how software behaves when we greatly increase its size**.

Whenever the gravity of a problem increases proportionally with the size of the code, it means that we have a **scalability issue**. For instance, we all know that we [should avoid globals](https://www.oreilly.com/library/view/maintainable-javascript/9781449328092/ch06.html). Would it matter if we use _"a few"_ globals in a small code base for a personal project? Of course not.

However, _**using globals as a practice**_ within a team of several developers, working on a long-term project that spans over many years, will surely become a **huge maintainability problem**, sooner or later.

<br />

Now, each of us has their own definition of _"what a large project is"_, in order to understand when these scalability problems might start to surface. From my own experience, CSS scalability problems become visible:

- during projects that span over **more than 6 months**;
- with projects having **at least 3 developers** working on the UI.

## Common CSS problems

Before going any further to discuss the scalability solutions, we must understand the issues that they're trying to solve. So, let's take a look at some of the most concearning problems when we talk about CSS scalability:

1. [Zombie code](#zombie-code)
2. [Naming collisions](#naming-collisions)
3. [Specificity wars](#specificity-wars)
4. [Source order precedence](#source-order-precedence)
5. [Selector duplication](#selector-duplication)
6. [Cumbersome media queries (poate il punem impreuna cu Selector duplication)](#cumbersome-media-queries)
7. [Implicit dependencies](#implicit-dependencies)
8. [Shared design tokens](#shared-design-tokens)
9. [Lack of type-safety](#lack-of-type-safety)

### Zombie code

CSS code, like any other code, will increase in size indefinitely. The particular problem with CSS is that `.css` files size will grow even when we remove HTML code that references CSS selectors defined in those files. This usually happens when:

- We remove HTML markup, but forget to delete the associated styles.
- We want to delete the associated styles, but we have no idea if they are used elsewhere on the code base. So, instead of breaking any existing code, we choose not to touch them.

We avoid deleting _unused CSS code_ because it's almost impossible to detect if they are really _unused_, in order to be safely removed.

<br />

<SideBySide left={{lang: "HTML", file: "page.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html
<p class="promo">
  <h2>Promo title</h2>

  <!-- This will get removed at some point... -->
  <p>Promo text ...</p>

  <a href="/promo">Check this out</a>
</p>
```

```css
.promo {
  font-size: 1.5em;
}

/* Styles will be left in the codebase */
.promo p {
  color: rebeccapurple;
}
```

</SideBySide>

As time goes by we'll surely ship more CSS code than is actually needed, slowing down the page load and making the code base less and less manageable. This happens because CSS cannot be statically analyzed, therefore no tool could safely tell us which CSS selectors from our source code are not used.

There are tools to [detect unused CSS](https://developer.chrome.com/docs/devtools/coverage/) in static websites and even some attempts to [remove unused CSS](https://css-tricks.com/how-do-you-remove-unused-css-from-a-site/). However, they work only to some extend.

<Subheading>
  <Status type="ok" />
  Solutions
</Subheading>

<p>
  <LinkTo part={6} /> and <LinkTo part={7} /> address the issue of zombie code,
  successfully removing unused CSS styles.
</p>

### Naming collisions

Reusable class names usually contain common nouns, like `.modal`, `.button`, `.overlay`, etc. If we include an external file that defines the same class names they could get overwritten, depending on which file is included last.

<Subheading>Namespacing</Subheading>

CSS lacks the concept of namespace, so the language itself doesn't help us to prevent style overwritting. A common solution to this problem is to add a project specific **prefix**, for instance `.abc-overlay`. Third party libraries usually implement this approach.

However, this does not guarantee unique names. When dealing with many large files, how could we be sure that nobody else added the class `.abc-heading-large`? We could **search the entire code base** to see if we find such a already class defined.

<Subheading>Computed class names</Subheading>

Manually searching for existing class names works for static classes. However, we might deal with **dynamic** class names, computed using some custom logic that prevents searching for a string like `.abc-heading-large`:

```js
const classname = `abc-heading-${isPromo ? "large" : "small"}`;
```

<br />

Not to mention that we could include stylesheets written by a different team. In this case, making sure that we don't have any collitions can become quite a challenge.

<!-- But no stress, we can solve any such issues using a **higher specificity**, right? -->

<Subheading>
  <Status type="ok" />
  Solutions
</Subheading>

There are many solutions to this problem, some better than others:

- <LinkTo part={4} /> covers how we can avoid this manually;
- <LinkTo part={5} /> covers out of the box solutions using utility classes;
- <LinkTo part={6} /> covers tools that solves the naming collisions automatically.

### Specificity wars

One way to avoid naming collitions is to increase the "strength of a selector", or the so called [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity). This definitely works on the short run, but it usually gets out of control at some point:

```css
/* we start with a simple generic "title" class */
.title {
}

/* we use the same class name, for a specific "product" component */
.product .title {
}

/* but we also have a modified "discounted" variation */
.product .title.discount {
}

/* also, there's a different variation inside the "promo" section */
#promo .product .title.discount {
}

/* not to mention the "dark theme" styles */
.dark-theme #promo .product .title.discount {
}

/* to avoid specificity problems, we'll end up using "!important" */
.special.title {
  color: blue !important;
}
```

Relying on specificity to overwrite styles usually creates a [Snowball effect](https://en.wikipedia.org/wiki/Snowball_effect), forcing everyone on the team to further increase specificity, thus making it harder and harder to overwrite styles.

Eventually, the only way to define new styles will be using `!important`. Once we reach that scenario, the code base will be almost impossible to extend.

<Subheading>
  <Status type="ok" />
  Solutions
</Subheading>

Similar to naming collisions, there are many solutions to this problem:

- <LinkTo part={3} /> instruct us to keep specificity "low";
- <LinkTo part={4} /> teach how we can maintain a low specificity and prefer composition
  for overwritting;
- <LinkTo part={5} /> covers out of the box solutions using utility classes.

### Source order precedence

Ok, let's say that we stick to a low specificity and that we manage somehow to avoid naming collisions. One thing to keep in mind is that when specificity is the same, source code order takes place: _styles declared later always win_.

Consider the following trivial example:

<Side header={{ file: "page.html", lang: "HTML" }}>

```html
<p class="red blue">Red or Blue?</p>
```

</Side>

If we look at the `.html` file, we might think that the text will be have the `.blue` class applied. But it's not the order of CSS classes that we apply to the HTML element that matters. It's the order of the styles defined in the CSS stylesheets.

<!-- prettier-ignore-start -->

<Side header={{ file: "styles.css", lang: "CSS" }}>

```css
.blue { color: blue; }
.red { color: red; }
```

</Side>

<!-- prettier-ignore-end -->

When looking at the `.css` file, we see that `.red` is defined later, which means that its styles will win, because both selectors have the same specificity.

<br />

Now, let's look at 3 different scenarios that could seriously affect us:

1. Consider that you're adding a new class to override some styles, but it doesn't work, because other styles defined later in code take precedence.
2. Consider breaking the styles of a page only because we refactored our stylesheet by changing the order of some styles.
3. Working with dynamically loaded stylesheets could become a real nightmare, because styles resolution will become un-deterministic.

### Selector duplication

When using plain CSS, defining any pseudo class, pseudo element, or media query will force us to duplicate the CSS selector:

<!-- prettier-ignore-start -->
```css
.product_title { }

.product_title:hover { }
.product_title::after { }

@media (min-width: 768px) {
  .product_title { }
  .product_title::after { }
}
```
<!-- prettier-ignore-end -->

Duplicating selectors during development is not a real scalability problem, more of an annoying issue. But during various refactorings such as renaming, moving, or deleting, dealing with a multitude of duplicated classes could become tricky.

Any feature that impedes code maintenance could potentially become a scalability concern.

### Cumbersome media queries

An even bigger problem we'll face is when we have to deal with responsive web pages and media queries. There are 2 different ways we can group our styles: **by media query** or **by CSS selector**:

<br />

<!-- prettier-ignore-start -->

<SideBySide left={{lang: "CSS", file: "Group by media query"}}  right={{lang: "CSS", file: "Group by CSS selector"}}>

```css
/* line 23 */
.product { }
.product_title { }
.product_body { }

...

/* line 163 */
@media (min-width: 768px) {
  .product { }
  .product_title { }
  .product_body { }
}

...

/* line 390 */
@media (min-width: 1280px) {
  .product { }
  .product_title { }
  .product_body { }
}
```

```css
.product { }
@media (min-width: 768px) {
  .product { }
}
@media (min-width: 1280px) {
  .product { }
}

.product_title { }
@media (min-width: 768px) {
  .product_title { }
}
@media (min-width: 1280px) {
  .product_title { }
}

.product_body { }
@media (min-width: 768px) {
  .product_body { }
}
@media (min-width: 1280px) {
  .product_body { }
}
```

</SideBySide>

<!-- prettier-ignore-end -->

<br />

<Subheading>Groupping by media query</Subheading>

As developers, we usually try to avoid code duplication as much as possible. Groupping by media query defines the media queries only once, so it's probably a more approach appealling. The downside is that it's very difficult to read, understand, and maintain such a code. The styles for a single element could be split in different parts of the file. **Figuring out which are all the styles that apply to a particular selector becomes a real scalability problem.**

<Subheading>Groupping by CSS selector</Subheading>

To enable an easier understanding of the code, which is crucial when we think about scaling, we could group the styles by CSS selectors. Using this approach, we don't have to search the whole file to figure out which styles apply to a certain selector. **The downside is that there's more boilerplate and the output is larger.**

<!-- ### Cumbersome design tokens sharing

CSS custom properties commonly known as "CSS variables" are very useful to avoid certain types of code duplication, such as colors, breakpoints, fonts sizes, spacing values, etc. These values are usually called **design tokens** and they're required in design systems, but also very useful in any application that doesn't use a strict system.

Extracting design tokens as variables provides easy reusability and maintainability. They are easy to change, because there's a single source of truth.

Also, theming becomes much easier to implement. If we think about dark mode, which is pretty popular nowadays, theming is not a scarce feature anymore. -->

### Implicit dependencies

### Shared design tokens

-> adaptive layouts, access breakpoints in logic

### Lack of type-safety

Before using TypeScript or other strongly typed languages, I never thought about the highly dynamic nature of CSS. I thought that there isn't any other way, so I got used to it.

But after I started using statically typed languages, I've begun to feel the lack of type-safety when authoring and maintaining either plain CSS, accompanied by preprocessors, or CSS modules:

- **Missing a "go to definition" or "find references"** feature, which is very useful in debugging, to determine which styles apply to a particular element, or where is a paticular class name applied. Instead, we must use copy the class name from the markup and search for it in the stylesheet, or vice-versa.
- **Refactorings are not safe** because the tooling doesn't help highlighting any syntax errors when renaming class names, or removing them. This alone will lead to developers being afraid to touch or modify any existing code, which could ultimately lead to [code rot](https://en.wikipedia.org/wiki/Software_rot).

<Note>
  It's important to keep in mind that none of the previously mentioned concerns
  are a problem if we work alone on a small project. But they will become real
  problems when working on larger projects, together with other developers.
</Note>

---

In part 2 of this series we'll cover **preprocessors**.
