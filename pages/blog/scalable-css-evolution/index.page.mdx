import { BlogPost } from "../../../components/blog/blog_post";
import { Subheading } from "../../../components/blog/subheading";
import { SideBySide } from "../../../components/blog/sidebyside";
import { Status } from "../../../components/blog/status";
import { Note } from "../../../components/blog/note";
import { LinkTo } from "./toc";

import { meta } from "./meta";
export { meta } from "./meta";

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

I've been writing StyleSheets since 2000. A lot has changed since then regarding what we're able to achieve with CSS.

One thing I came to understand is that there's a significant difference between the CSS code that we write for **small websites** and the one developed for **large applications**. Single developers working on a project that will end in a few months can write CSS in any way they like. Poorly written code will probably not impact the success of the project.

On the other hand, when we think about teams with multiple developers, poorly written CSS can hugely influence the project's development during the course of many years. It's not a secret that writing CSS at scale is not trivial: I've read about it in articles and blog posts, I've listened to it during conference talks, and I've personally experienced it multiple times.

CSS features were always years behind the current needs of the community. Unfortunately, that's something that will probably never change. To combat CSS limitations, developers had to invent all sorts of tools to aid them in writing scalable CSS.

You can view this series as a **chronicle**, describing how these tools have evolved over time and the current state of writing _maintainable CSS at scale_.

> A chronicle is a recording of significant historical events in the order of their occurrence, as seen from the chronicler's perspective.

## Overview

In **<LinkTo part={1} />**, we'll explore 8 of the most significant problems that developers are usually facing when writing large scale CSS, namely **selector duplication**, **naming collisions**, **specificity wars**, **source order precedence**, **implicit dependencies**, **zombie code**, **shared variables** and **lack of type-safety**.

**<LinkTo part={2} />** covers various tools that enriched CSS with new syntax, allowing us to write more maintainable source code by significantly reducing **selector duplication**. It was only a tiny step forward, but nevertheless a crucial one.

**<LinkTo part={3} />** walks through some of the essential techniques introduced by various thought leaders, required to write maintainable CSS, with or without the help of preprocessors, to avoid **naming collisions** and **specificity wars**.

In **<LinkTo part={4} />**, we'll discuss two related topics. First, we'll look at various _CSS methodologies_ that brought together the good practices in a concise and explicit set of rules. Second, we'll discuss the _Semantic CSS approach_, encouraged by the HTML5 specification, which most CSS methodologies and frameworks embrace.

**<LinkTo part={5} />** debates an alternative approach that contradicts and breaks all the principles of Semantic CSS. This shift gave birth to a whole new set of frameworks based solely on single-purpose utility classes.

**<LinkTo part={6} />** focuses on the tools used for CSS scoping, resolving all the problems regarding **naming collisions**, **specificity wars**, **source order precedence**, and reducing the amount of **zombie code**. Styles encapsulation became an industry standard, adopted by all component-based JavaScript frameworks.

**<LinkTo part={7} />** covers another novel approach, by moving CSS definitions to JavaScript files, resulting in countless benefits, such as **explicit dependencies**, **shared variables**, not to mention all the features of styles encapsulation, CSS preprocessors, Atomic CSS, and so much more.

In **<LinkTo part={8} />**, we'll see how adding TypeScript on top of CSS-in-JS provides type checking for CSS, enabling _safe refactorings_ and _typed interfaces_ when authoring UI components, being the missing puzzle piece when aiming for a complete **type-safe code** base.

---

So, let our journey begin with <LinkTo part={1} /> because we cannot discuss the solutions unless we understand the problems they are trying to solve.
