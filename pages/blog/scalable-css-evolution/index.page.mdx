import { BlogPost } from "../../../components/blog/blog_post";
import { Subheading } from "../../../components/blog/subheading";
import { SideBySide } from "../../../components/blog/sidebyside";
import { Status } from "../../../components/blog/status";
import { Note } from "../../../components/blog/note";
import { LinkTo } from "./toc";

import { meta } from "./meta";
export { meta } from "./meta";

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

I've been writting CSS since 2000. A lot has changed since then regarding what we're able to achieve with CSS.

One thing I came to understand is that there's a significant difference between the CSS code we write for **small websites** and the one developed for **large applications**. Single developers working on a project that will end in a few months can write CSS in any way they like. Poorly written code will probably not impact the success of the project.

But when we think about teams with multiple developers, during the course of many years, poorly written CSS can hugely influence the project's development.

CSS features were always years behind the current needs of the community. That's something that will probably never change. To combat CSS limitations, developers had to invent all sorts of tools to aid them in writting CSS at scale.

---

You can view this series as a **chronicle**, describing how these tools have evolved over time and what is the current state of writting maintainable CSS at scale.

> A chronicle is a recording of important or historical events in the order of their occurrence, seen from the perspective of the chronicler.

## Long story short

In **<LinkTo part={1} />** we'll explore 8 of the most significant problems that developers are usually facing when writting large scale CSS, namely **zombie code**, **naming collisions**, **specificity wars**, **source order precedence**, **selector duplication**, **implicit dependencies**, **shared design tokens** and **lack of type-safety**.

**<LinkTo part={2} />** covers various tools that enriched CSS with new syntax, allowing us to write more maintainable source code by greatly reducing **selector duplication**. It was only a small step forward, but nonetheless a crucial one.

**<LinkTo part={3} />** walks through some of the essential practices, introduced by various thought leaders, required to write maintainable CSS, with or without the help of preprocessors, in order to avoid **naming collisions** and **specificity wars**. However, these practices are quite difficult to apply.

In **<LinkTo part={4} />** we'll discuss two related topics. First, we'll take a look at various _CSS methodologies_, that brought together a set of good practices in a concise set of rules, much easier to apply. Second, we'll discuss the _Semantic CSS approach_, encouraged by the HTML5 specification, which is embraced by most CSS methodologies and frameworks.

**<LinkTo part={5} />** debates an alternative approach that contradicts and breaks all the principles of Semantic CSS. This mindshift gave birth to whole new set of frameworks.

**<LinkTo part={6} />** focuses on the tools used for CSS scoping, resolving all the problems regarding **naming collisions**, **specificity wars**, **source order precedence** and also reducing the amount of **zombie code**. Styles encapsulation became an industry standard, adopted by all component-based JavaScript frameworks.

**<LinkTo part={7} />** covers another mindshift, by moving CSS definitions from stylesheet files to JavaScript files, resulting in countless benefits, such as **explicit dependencies**, **shared design tokens**, plus all the benefits of styles encapsulation, CSS preprocessors, Atomic CSS and so much more.

In **<LinkTo part={8} />** we'll see how adding TypeScript on top of CSS-in-JS provides **type-safety** for CSS styles, enabling _safe refactorings_ and _typed interfaces_ when authoring UI components.

---

So, let our journey begin with <LinkTo part={1} />, because we cannot discuss the solutions, unless we understand the problems that they are trying to solve.
