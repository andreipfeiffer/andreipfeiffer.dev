import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { TOC, LinkTo } from "../toc";

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 3;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

In the previous article <LinkTo part={CURRENT_PART - 1} /> we've witnessed how pre-processors enabled us to author more maintainable CSS code by considerably reducing duplication, while post-processing optimized the output automatically.

During this part we will continue our journey to overcome the problems with CSS maintainability, focusing on avoiding complex CSS selectors and specificity wars.

Let's explore some essential good practices introduced by various thought leaders:

- [Keeping specificity low](#keep-specificity-low)
- [Prefixing class names](#prefix-class-names)
- [Avoid applying styles on IDs](#avoid-applying-styles-on-ids)
- [Avoid type selectors](#avoid-type-selectors)
- [Avoid mimicking HTML structure](#avoid-mimicking-html-structure)
- [Avoid repetition](#avoid-repetition)
- [Avoid using `!important`](#avoid-using-important)

<Note title="Notes">
  <ul>
    <li>
      This is not at all a comprehensive list as this is a huge topic in itself.
    </li>
    <li>
      As their name suggest, these are <strong>practices</strong>, not dogmas.
      Even if we treat them like rules, there are always understandable{" "}
      <strong>exceptions</strong>.
    </li>
  </ul>
</Note>

## Keep specificity low

The <LinkTo part={1} hash="specificity-wars">specificity war</LinkTo> is one of the most dreadful problems to face as a UI developer. To avoid it, we must keep specificity as low as possible.

Sometimes we tend to be overzealous when writting CSS selectors, instead of keeping them simple. Defining **overly specific CSS selectors** by abusing [descendant combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator) will result in high specificity, while also coupling the targeted element with the HTML structure:

<!-- prettier-ignore-start -->
```css
/* ‚ùå BAD: overspecific selector (0.4.3 specificity) */
.header .main_menu ul li.item a.link {}
```
<!-- prettier-ignore-end -->

Let's analyze this code for a second:

- If there is a single `.main_menu` element on the page, then `.header` is not necessary at all. In case there are more than one, we could use a different class name, like `.header_main_menu`.
- The descendants `ul li.item` should not be necessary if the `a.link` elements are placed only inside the `ul`. Otherwise, if we have them outside as well, and we need different styles, it means they are different elements, so they should have different class names.
- Last but not least, nobody should care that the `.link` is also an `a` element.

<br />

Thus, the above selector could be easily simplified, while also reducing its specificity:

<!-- prettier-ignore-start -->
```css
/* üëç GOOD: less specific selector (0.2.0 specificity) */
.main_menu .link {}

/* ‚úÖ BEST: simple selector (0.1.0 specificity) */
.main_menu_link {}
```
<!-- prettier-ignore-end -->

<br />

With CSS pre-processors it's even more easier to create high specificity, thanks to their nesting feature. We often use **excessive nesting**, which is way too overused and creates significant scalability problems.

<SideBySide left={{lang: "SCSS", file: "style.scss (source)"}}  right={{lang: "CSS", file: "style.css (output)"}}>

```scss
// ‚ùå excessive nesting
.main_menu {
  ul {
    li {
      .link {
      }
    }
  }
}
```

```scss
// ‚ùå overspecific CSS output
.main_menu {
}
.main_menu ul {
}
.main_menu ul li {
}
.main_menu ul li .link {
}
```

</SideBySide>

<br />

We could easily reduce the specificity of the output CSS selectors by limiting the number of nesting levels:

<SideBySide left={{lang: "SCSS", file: "style.scss (source)"}}  right={{lang: "CSS", file: "style.css (output)"}}>

```scss
// üëç less nesting
.main_menu {
  ul {
  }
  li {
  }
  .link {
  }
}
```

```scss
// üëç lower specificity output
.main_menu {
}
.main_menu ul {
}
.main_menu li {
}
.main_menu .link {
}
```

</SideBySide>

<br />

<Subheading>So, how low is "low enough"?</Subheading>

Keeping specificity low is definitely going to be helpful on the long run. But what exactly does "low" mean? How "low" should we keep it and when does it become "too high"?

A rule of thumb used to say that _CSS selectors should not have more than 2 descendants or levels of nesting_. Thus, it's common sense to say that:

- use **a single CSS class** as the goto option: `.main_menu_link`;
- use **1 descendant** when overriding is necessary: `.dark-theme .main_menu_link`;
- use **2 descendants only in extreme scenarios** when the previous rules don't apply.

## Prefix class names

In a previous part of this series we talked about potential <LinkTo part={1} hash="naming-collisions">naming collisions</LinkTo>. Since CSS doesn't natively support namespacing, we could use a workaround by **adding a prefix** related to the project to each CSS class name that we define. This would greatly reduce the collision chance with external styles.

The prefix should be short and concise. To give an example, I could use `pf-`, the first 2 letters from my last name, as a prefix for the class names defined for this website.

<!-- prettier-ignore-start -->
```css
/* ‚ùå could be potentially overridden */
.header {}

/* üëç less likely to be overridden */
.pf-header {}
```
<!-- prettier-ignore-end -->

<Subheading>Exceptions</Subheading>

There are many situations where prefixing is not necessary:

<!-- prettier-ignore-start -->
```css
/* üëç utility classes */
.rounded {}

/* üëç nesting elements */
.pf-header .logo {}
```
<!-- prettier-ignore-end -->

<Note>
  Well-written libraries use prefixes for their styles to avoid naming
  collisions when included in actual projects.
</Note>

## Avoid applying styles on IDs

Sometimes _we might think_ that an HTML block will only be displayed once on the page, so we could be inclined to use [ID selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors) for styling. Such examples might include the **page's header**, the **contact form**, or the **product details page**.

There are two major problems that could occur when we apply styles on ID selectors:

<Subheading>1. Unexpected overriden styles</Subheading>

Let's consider an HTML block called `.profile`, which contains an `.image` element. This block of content is used in the top header of our application to indicate the logged in user:

<SideBySide left={{lang: "HTML", file: "top-header.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html
<div class="profile">
  <img src="..." class="image" />
</div>
```

```css
.profile .image {
  border: 1px black solid;
}
```

</SideBySide>

<br />

At some point, we want to reuse the `.profile` content block on a different page or part of our application, that also contains an `.image` element, but in this case we use an **ID selector** in CSS:

<SideBySide left={{lang: "HTML", file: "post-details.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html{4}
<div id="post-details">
  <img src="..." class="image" />

  <!-- include the .profile block here -->
</div>
```

```css
/* IDs have higher specificity than classes */
#post-details .image {
  border: 10px grey solid;
}

.profile .image {
  /* these style will get overridden */
  border: 1px black solid;
}
```

</SideBySide>

<br />

In these circumstances, the `.profile .image` styles will get overridden by the more specific `#post-details .image` selector. We could change the class names to avoid collisions, but the fundamental problem still remains: **reusing HTML blocks could render different styles, depending on where we include them**.

Any non-deterministic behavior is a potential critical problem when we think about scalability and long-term maintainability.

<Subheading>2. Lack of reusability</Subheading>

Last time I checked, [foreseeing](<https://en.wikipedia.org/wiki/Foresight_(psychology)>) future needs is very debatable. My own past experiences strongly support that we are generally bad when making predictions.

It happened to me so many times to think that _"we'll never have more than one Contact Form"_. But one week later, we needed to add a _Subscribe Form_, which had to look exactly the same as the _Contact Form_.

<!-- prettier-ignore-start -->
```css
/* ‚ùå code smell which proves that we cannot foresee the usage of code blocks */
#contact-form,
#subscribe-form {}
```
<!-- prettier-ignore-end -->

<br />

So, to avoid any of the problems mentioned above, it's so much easier to avoid applying styles on ID selectors and simply use classes instead:

<!-- prettier-ignore-start -->
```css
/* ‚ùå avoid using ID selectors in CSS */
#contact-form {}

/* ‚úÖ use classes instead */
.contact-form {}
```
<!-- prettier-ignore-end -->

<Note>
  It's perfectly fine to use IDs for other purposes, like{" "}
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#linking_to_an_element_on_the_same_page">
    anchor links
  </a>
  . What should be avoided is using them in CSS selectors.
</Note>

## Avoid type selectors

CSS [type selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors) match HTML elements by their tag name. The problem is that using this approach will **create a coupling between the markup and the styles**. Changing the markup will break the styles in an unexpected way.

Let's consider the following scenario:

- we have a `.card` element, that contains a title placed inside an `h2`;
- we apply the styles using the `.card h2` selector;
- for some reason, somebody needs to replace the `h2` with an `h3`, which apparently is a trivial change and it shouldn't break anything;
- debugging such a problem can become a serious issue, because the styles are applied implicitly, not explicitly.

Thus, the **styles will be coupled with the markup**. We cannot change the markup without updating the styles as well. Whenever we a have a **tight coupling** between parts of code that should be modified independently, without affecting one-other, we have a scalability problem.

<!-- prettier-ignore-start -->
```css
/* ‚ùå avoid HTML tag names */
.card h2 {}

/* ‚úÖ classes are way more flexible */
.card .title {}
```
<!-- prettier-ignore-end -->

<br />

The solution is very simple: **avoid targetting HTML tags in CSS and use classes instead**. This will create an explicit dependency between the styles and the markup, being easy to debug. In addition, changing the markup will not affect the styles.

<Subheading>Exceptions</Subheading>

I still follow this rule pretty strictly, even nowadays. However, there are a few exceptions where type selectors are helpful, or even required:

1. **Resetting or normalizing CSS** implicit styles;

2. **Styling dynamic content from a headless CMS** where we get plain HTML content without any class names, so we must target elements by their type, for instance `.blog_post h2`.

## Avoid mimicking HTML structure

Sometimes we might be inclined to define CSS selectors based on an existing HTML structure. Similar to the previously described problem, mimicking the HTML structure in our CSS code will once again couple the markup with its styles, thus producing **rigid CSS code**.

<!-- prettier-ignore-start -->
```scss
// ‚ùå BAD: unneeded "nav" ancestor
.main_menu nav .link {}

// üëç GOOD: less structure dependent
.main_menu .link {}

// ‚úÖ BETTER: using a single class
.main_menu_link {}
```
<!-- prettier-ignore-end -->

Another common scenario to mimic the HTML structure is using **strict combinator selectors** such as [child combinator](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator) or [adjacent sibling combinator](https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator) when it's not appropiate:

<!-- prettier-ignore-start -->
```css
/* ‚ùå What if we need to wrap the logo in a <div />? */
.header > .logo {}

/* ‚ùå What if we need to display the label first? */
.checkbox + .label {}
```
<!-- prettier-ignore-end -->

## Avoid repetition

Before the concept of components became popular, we had much more repetition in our code, CSS making no exception. The tendency is to add the required CSS rules for a specific feature, without looking back and analysing whether an abstraction could be extracted and reused. For instance:

```css{4,9,17}
.product-card {
  border-radius: 10px;
  border: 1px #aaa solid;
  padding: 16px;
  background: #fafafa;
}

.contact-form {
  padding: 32px;
  border-radius: 10px;
  border: 1px #aaa solid;
  background: #fafafa;
}

.shopping-cart-list {
  border-radius: 10px;
  padding: 24px;
  border: 1px #aaa solid;
  background: #fafafa;
}
```

The only thing that is different on these 3 CSS rules is the `padding`, while everything else is the same. So, to avoid this repetition and to reuse these styles, we can extract the common styles into a separate, more abstract class, employing the DRY principle:

```css{1-5}
.box {
  border-radius: 10px;
  border: 1px #aaa solid;
  background: #fafafa;
}

.product-card {
  padding: 16px;
}

.contact-form {
  padding: 32px;
}

.shopping-cart-list {
  padding: 24px;
}
```

The `.box` class can be easily composed with other classes, making it **more flexible**. In addition, there's only one source of truth, so whenever we need to change the styles, we'll update a single class.

<br />

We could go a step further and create a bunch of **utility classes**, like generic styles for [accessible hidden content](https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html), or custom styles that could encapsulate even a single CSS rule:

<!-- prettier-ignore-start -->

```css
.rounded {
  border-radius: 10px;
}
.bordered {
  border: 1px #aaa solid;
}

.color-primary {}
.color-secondary {}
```
<!-- prettier-ignore-end -->

Such utility classes are still widely used today in most CSS frameworks. They also gave birth to dogmatic approaches such as <LinkTo part={5}>Atomic CSS</LinkTo>, which takes the practice of _one CSS rule per class_ to the extreme.

## Avoid using `!important`

The last covered good practice, but not the least important one, is to avoid using `!important` as an atempt to fix the specificity wars. Many of us tried, none of us succedeed. It's a loosing battle. Even [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#:~:text=Using%20!important%2C%20however%2C%20is%20bad%20practice%20and%20should%20be%20avoided) documents it as a **bad practice**.

If we end up using `!important` to fix the specificity wars, it won't take long until the **!important wars** will start. It is guaranteed that at some point we'll need to override already `!important` rules. It's possible, but it's disastrous.

> When we end up overriding an `!important` CSS rule, we hit rock bottom regarding CSS maintainability!

<Subheading>Exceptions</Subheading>

Imagine the irony: even such an important good practice, to avoid using `!important`, has a few important exceptions worth mentioning:

1. **Overriding 3rd party styles** when they have high specificity cumbersome to override using conventional methods.

2. **Defining abstract utility classes** such as `.bold` or `.align-center`, because they could be easily overriden accidentally.

---

## The problems with good practices

Once we learn and understand these good practices it should be fairly easy to apply them, right? Unfortuntely, it's not a trivial task at all.

- There is **no official comprehensive guide** on how to write maintainable CSS. I've only covered a few of the most important good practices, but there are so many more.
- Some of the **good practices don't apply equally** on every project, with every team. Also, developers tend to be very opinionanted, so we rarely reach consensus regarding a specific set of rules.
- Being so many practices and most of them quite debatable, they are **cumbersome to learn and teach**.
- As we've seen, there are plenty of **acceptable exceptions** that apply to every practice. It's often quite difficult to draw a line when is it acceptable to break the rule.
- Most of the important good practices are **impossible to enforce**. The only weapon is constant code review, trainings and mentoring.
- Once we have an existing large application written without these practices in mind, they become **very difficult to introduce onto an existing code base**. Changing CSS in general is a fragile task, so most developers avoid changing it.
- Last but not least, **good practices don't scale**! The larger the code base, the more burdensome the maintenance will become.

<br />

In the upcoming chapter <LinkTo part={CURRENT_PART + 1} /> we'll explore various **methodologies** and **architectures**, built on top of many of the good practices that we've covered here, but providing a structured and cohesive set of principles and rules.
