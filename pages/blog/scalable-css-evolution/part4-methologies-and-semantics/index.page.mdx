import { BlogPost } from "../../../../components/blog/blog_post";
import { Note } from "../../../../components/blog/note";
import { SideBySide } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Subheading } from "../../../../components/blog/subheading";
import { TOC, LinkTo } from "../toc";

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 4;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

In the previous article, <LinkTo part={CURRENT_PART - 1} />, we've covered several techniques that help us write more maintainable CSS. However, they have quite a few significant limitations. In addition, they don't teach us much about how to reuse larger blocks of code.

In this article, we'll take a look at various **methodologies** and **architectures** built on top of many of the good practices that we've covered, which provide a structured and cohesive set of principles and rules.

<Note>
  We won't dive into the details of any methodology as there are plenty of
  resources available. Instead, we will focus on the fundamental contributions
  of each approach regarding the evolution of scalable CSS.
</Note>

## The birth of components

[**OOCSS**](https://github.com/stubbornella/oocss/wiki) was coined by **Nicole Sullivan** in [2010](http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/). It stands for **Object Oriented CSS**. OOCSS was one of the first approaches that taught us to identify _repeating visual patterns_ and develop _re-usable abstract objects_ in CSS.

> An object should look the same, no matter where you put it.

The term **component** was not popularized at that time, but the resemblance is obvious between how we think about components today and how Nicole described her **objects**. Not to mention that she also referred to them as _"web Lego"_.

<Subheading>
  <Status type="ok" /> Takeaways:
</Subheading>

There are two essential things to take away from OOCSS that are still applicable in today's applications:

1. **Separate container from content**, or in other words, the objects (or components) should provide only the abstract container, while the consumers of the objects should provide their own specific content. This way, we gain **high reusability**. In today's terms, we usually refer to _"content"_ as `Props`, `Input`, or in a general way, _"data passed to the component"_.
2. **Separate structure from skin**, or in other words being able to apply different skins to the same structure. This way, we gain **high extensibility and customization**. Nowadays, we usually refer to _"skins"_ as `variants` or `themes`.

However, OOCSS focused more on the principles of what a component is and how to implement it. Therefore, it doesn't provide enough details regarding the technicalities of writing the required CSS code.

## Naming conventions

[**BEM**](https://en.bem.info/methodology/key-concepts/) was developed at **Yandex** long before OOCSS, used internally under different names. However, it was [open-sourced](https://en.bem.info/methodology/history/#bem-and-open-source-2010) only in 2010.

BEM stands for **Block-Element-Modifier**, being a _component-based_ approach to web development. It taught us to think of our pages and application screens as a hierarchy of independent **Blocks**, which we call Components nowadays. Therefore, any Block could be used in any part of any page of the application. Likewise, any Block can contain other Blocks.

Blocks can also contain **Elements**, which represent content dependent on their respective Block. If an Element is independent, meaning that it could be used anywhere else, not only inside a specific Block, it becomes a Block itself.

Last but not least, both Blocks and Element can be customizable by one or more **Modifiers**.

> The BEM methodology defines **CSS selector naming conventions** that solve a range of web [development problems](https://en.bem.info/methodology/solved-problems/).

As far as I know, BEM is the first approach that proposed using **a single, unique, and semantic CSS class** to identify and differentiate its key concepts:

- `.main-menu` could be the name of the **block** CSS class;
- `.main-menu__item-link` could be the name of an **element** of the block, which makes no sense outside of the block it belongs to;
- `.main-menu--sticky` and `.main-menu__item-link--active` could be the name of **modifiers** for the block and the element, respectively.

<Subheading>
  <Status type="ok" /> Takeaways:
</Subheading>

BEM truly emphasized the _component-based mindset_ in UI development. But probably the important legacy that BEM popularized is the naming conventions using a low and non-increasing specificity, which scales pretty well from a technical perspective.

We don't need descendant combinators if we use **unique CSS class names**, resulting in **low specificity** for the majority of our code;

<!-- prettier-ignore-start -->
```css
/* ❌ descendants increases specificity */
.main-menu .link {}

/* ✅ if the class name is unique, we don't need descendants */
.main-menu__link {}
```
<!-- prettier-ignore-end -->

<br />

In addition, we can easily **override CSS rules by composing multiple classes** on the same element, thus avoiding increasing the specificity.

<SideBySide left={{lang: "CSS", file: "style.css"}}  right={{lang: "HTML", file: "page.html"}}>

```css
/* ❌ nesting increases specificity */
.main-menu .main-menu--sticky {
}

/* ✅ the class name being unique, we don't need nesting */
.main-menu--sticky {
}
```

```html
<!-- we override by composing class names -->
<ul class="main-menu main-menu--sticky">
  ...
</ul>
```

</SideBySide>

## High-level architecture

So far, we've only looked at individual component styling techniques. But when architecting an entire website or application, structuring all the CSS code becomes an important task, as well. We need to maintain various types of CSS rules: default styles, re-usable styles, non-reusable styles, utility classes, etc. That's where CSS architectures started to emerge.

- [**SMACCS**](http://smacss.com/book/) was the first popular methodology, architecture, or whatever you want to call it. It stands for _Scalable and Modular Architecture for CSS_ and it was coined by **Jonathan Snook** in [2011](https://snook.ca/archives/html_and_css/css-architecture).

- [**ITCSS**](https://csswizardry.net/talks/2014/11/itcss-dafed.pdf) is another popular architecture, introduced in 2014 by **Harry Roberts**. It stands for _Inverted Triangle CSS_.

<Subheading>
  <Status type="ok" /> Takeaways:
</Subheading>

As I mentioned, I won't dive into the specific details of each of these approaches. However, the essential thing to learn is that there are **multiple layers of CSS rules** that we need to consider when structuring the CSS code base for an entire application:

1. We have some **base rules**, very generic styles using only type selectors, no classes. These rules contain _CSS resets_, _typography_, _variables_, etc.
2. Then we have **layout rules** (or **objects** as called in ITCSS). These are typically abstract components containing minimal styling, used only for layout. Such components include _Grid systems_, _Media object_, _Stack_ and _Divider_ components, etc.
3. The above layout components will contain **concrete components** (or **modules** as called in SMACCS). These are the actual parts of UI that have application specific styling, which can be either highly re-usable components (like _Button_, _Modal_, _Form_ elements, _Tooltip_, etc) or domain-specific components (like _ProductCard_, _Breadcrumb_, _Carousel_, _Avatar_, etc) that are bound to the application domain.
4. Lastly, we have **overrides** (called **trumps** in ITCSS and **state** in SMACCS). These are single-purpose _utility classes_ that override other styles.

<Note>
  OOCSS approach and BEM naming conventions can also be used along with SMACCS
  and/or ITCSS. These methodologies don't exclude each other. They rather
  complement themselves.
</Note>

## Semantic CSS

At the time when these methodologies were coined, there was a strong buzz around [Semantic HTML](https://developer.mozilla.org/en-US/docs/Glossary/Semantics). Since CSS and HTML go hand in hand, it was a no-brainer that _"CSS should also be semantic"_. Even the [HTML5 specification](https://html.spec.whatwg.org/multipage/dom.html#:~:text=authors%20are%20encouraged%20to%20use%20values%20that%20describe%20the%20nature%20of%20the%20content%2C%20rather%20than%20values%20that%20describe%20the%20desired%20presentation%20of%20the%20content.) preaches this approach:

> [...] authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content.

And indeed, everything that we've talked about so far can be included in the **semantic approach of CSS**, which says that CSS class names should convey _meaning_, not _implementation_. In other words, a semantic name should express _what it represents_ and _not how it looks_.

```html
<!-- Semantic (conveys meaning) -->
<nav class="main-menu"></nav>

<!-- Non-Semantic (conveys implementation) -->
<nav class="flex column bg-dark pad-md align-center"></nav>
```

<br />

<Subheading>Semantic CSS Frameworks</Subheading>

The vast majority of CSS frameworks that we know today were built on top of many of the principles described above, imbracing the semantic CSS approach. Some of the popular semantic CSS frameworks include _Foundation_, _Bootstrap_, _Semantic UI_, _UIKit_ _Bulma_, and many more.

<!-- - [Foundation](https://get.foundation/) released in 2011;
- Twitter's widely adopted [Bootstrap](https://getbootstrap.com/) also released in 2011;
- The semantical [Semantic UI](https://semantic-ui.com/) in 2013;
- The lightweight [PureCSS](https://purecss.io/) also relesed in 2013;
- The minimalistic [UIKit](https://getuikit.com/) released in 2015;
- The CSS-only & no-JS [Bulma](https://bulma.io/) released in 2016, and many many more. -->

## The semantical problem

It's not a secret that Semantic CSS has some known shortcomings:

1. There's usually **a lot of repetition** in the written CSS rules. We'll surely have lots of `display: flex;`, `font-weight: bold;`, or `margin: 1em;` in our code, which results in larger than needed file size.
2. The size of our **CSS files will continually grow** as we develop new features, components, or pages. The reusability of styles is limited to the reusability of the components they relate to.
3. Anytime a single CSS rule changes, the **cached `.css` files will get invalidated**. Frequent styles updates could make the caching mechanism built in the browsers totally inefficient.
4. Last but not least, **naming things is inherently difficult**. In addition, making sure there are no class names collisions in the global namespace, with a continually increasing code base, is a daunting task.

---

Similar to [non-Euclidean geometry](https://en.wikipedia.org/wiki/Non-Euclidean_geometry), there's will always be someone to _question the status quo_. The same thing happened in 2013 with semantic CSS.

In the following article, <LinkTo part={CURRENT_PART + 1} />, we'll explore how to solve all the problems of semantic CSS by contradicting the fundamental principle that "class names should be semantic", using only utility classes that fully convey their implementation instead.

<br />

**References:**

- [About HTML semantics and front-end architecture](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/) by Nicolas Gallagher
- [CSS and Scalability](https://mrmrs.cc/writing/scalable-css/) by Adam Morse
- [Battling BEM CSS](https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/) by David Berner
