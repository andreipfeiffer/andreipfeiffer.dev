import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide, Side } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { Figure } from "../../../../components/blog/figure";
import { ThemedImg } from "../../../../components/blog/themed-img";
import { TOC, LinkTo } from "../toc";

import Image from "next/image";
import img_light from './styles-encapsulation-light.gif';
import img_dark from './styles-encapsulation-dark.gif';

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 5;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

In <LinkTo part={4} />, we've covered various CSS methodologies, including OOCSS, BEM, SMACSS, and ITCSS. They all adopted the Semantic CSS approach, which solves many maintainability problems, but only to some extent.

In this article we'll continue the Semnatic CSS pathway, by turning our attention to **styles encapsulation** and **CSS Modules**, which elegantly solve any _naming collisions_ while keeping a _low specificity_ at the same time. These techniques profoundly changed the way we author semantic CSS nowadays, becoming an industry standard.

<Figure
  width="grid"
  caption={
    "Scoped CSS was the first standard attempt to support styles encapsulation. As it didn't get traction, CSS Modules implemented encapsulation through tooling. Later, Shadow DOM was launched with native support."
  }
>
  <ThemedImg
    light={img_light.src}
    dark={img_dark.src}
    width={1920}
    height={880}
    alt="Timeline of scalable CSS evolution, highlighting the main timeline or Semantic CSS (in blue) and pinpoiting all style encapsulation techniques: Scoped CSS introduced in 2008 but abandoned later, CSS Modules in 2015 and Shadow DOM in 2016"
  />
</Figure>

## Scoped CSS

The problems with scalable and maintainable CSS were so critical that even WHATWG (Web Hypertext Application Technology Working Group) joined the battle. So, in 2011, the standards' commitee suggested that CSS stylesheets should have a [`scoped` attribute](http://html5doctor.com/the-scoped-attribute/):

> [...] it indicates that the styles are intended just for the subtree rooted at the style elementâ€™s parent element, as opposed to the whole Document.

<!-- prettier-ignore-start -->
```html
<!-- global styles -->
<style>
  p { color: blue; }
</style>

<div>
  <nav>
    <!-- <nav> scoped styles -->
    <style scoped>
      p { color: red; }
    </style>

    <p>red content</p>
  </nav>

  <p>blue content</p>
</div>
```
<!-- prettier-ignore-end -->

<br />

Let's see how it was supposed to work:

1. we have a global `<style>` that sets the color of all `p` elements to `blue`;
2. notice the `scoped` attribute on the inner `<style>` tag, where we change the color to `red` for all `p` elements;
3. however, these _scoped_ styles will only affect the subtree of `nav`, which is the parent of the `scoped` style declaration;
4. without the `scoped` attribute, the styles would affect the entire page, overriding the global `blue` color and rendering all `p` elements in `red`.

So, the Scoped StyleSheets spec addressed the global namespace problem, allowing us to define styles that don't affect elements outside the container of our choice, enabling **styles encapsulation**. This way, we would not need to worry about any naming collisions, or unexpected style overrides.

<br />

However, the spec was only implemented in [Firefox](https://caniuse.com/?search=scoped) (and removed in version 55) and experimentally in [Chrome](https://developers.google.com/web/updates/2012/03/A-New-Experimental-Feature-style-scoped). No other browser vendors showed any interest in implementing the feature.

Consequently, in 2016 the `scoped` attribute was [removed from the spec](https://github.com/w3c/csswg-drafts/issues/137) in favor of **Shadow DOM**, which has its own [scoping mechanism](https://developers.google.com/web/fundamentals/web-components/shadowdom#styling).

## CSS Modules

CSS features standardization is a lengthy process that could potentially take years to become implemented in most browsers. Thus, the developers' community couldn't just sit and wait for a solution. Therefore, in 2015, a few smart people released [CSS Modules](https://github.com/css-modules/css-modules) which solve styles encapsulation through tooling, instead of using standard syntax.

A **CSS Module** is a regular `.css` file, with some additional features, that can be compiled into an interchangeable format called [Interoperable CSS](https://github.com/css-modules/icss) (or ICSS):

<Side header={{ file: "styles.css", lang: "CSS" }}>

```css
.heading {
  color: blue;
}
```

</Side>

However, instead of including it as a regular StyleSheet, we import it from JavaScript files, using a [loader](https://webpack.js.org/loaders/css-loader/#modules) that implements the CSS modules specification:

<!-- prettier-ignore-start -->

<Side header={{ file: "page.js", lang: "JS" }}>

```js
// we import an Object from the .css file
import styles from "./style.css";

const element = document.querySelector("h1");

// all classes defined in the .css file
// are available as fields on the imported object
element.outerHTML = `<h1 class="${styles.heading}">Title</h1>`;
```

</Side>

<!-- prettier-ignore-end -->

Now, the beautiful part is the output, because the loader will automatically generate **unique class names** for each CSS class. Typically, the generated name has the form `filename__classname__hash`, but it can be customized:

<Side header={{ file: "HTML output" }}>

```html
<h1 class="page__heading__2fcab5">Heading</h1>
```

</Side>

<br />

So, what does this mean for us, the developers?

- **We don't have to worry about naming collisions and unexpected overrides** because the tooling takes care of this.
- We can **use class names relevant to a particular component** only. For example, different `.title` classes, defined in 2 separate components, will not collide with each other.

<br />

<Subheading>Explicit style dependencies</Subheading>

It's worth mentioning that with CSS Modules we must have a **separate `.css` file for each component**, which makes perfect sense because a component should have all its concerns grouped together: HTML markup, JavaScript behavior, and CSS styling.

<p>
  As seen in the above example, we have to explicitly <code>import</code> the stylesheet used by a particular component file when using CSS Modules. Therefore, styles are not{" "}

  <LinkTo part={1} hash="implicit-dependencies">
    implicit dependencies
  </LinkTo>{" "}
  anymore, which brings maintenance benefits that were not possible before:
</p>

- anyone can **easily figure out the source** of the styles;
- **unused styles don't get bundled** anymore when deleting the component.

## Frameworks

Style encapsulation became an industry-standard pretty fast. It made sense. It was simple. It had no compromises. As a consequence, most current frameworks implement or recommend some form of style encapsulation.

- **React** doesn't provide a built-in mechanism for styles encapsulation, but Create React App has [built-in support for CSS Modules](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/).

- **Vue.js** uses the abandoned `scoped` attribute to generate [encapsulated CSS](https://vue-loader.vuejs.org/guide/scoped-css.html) output.

- **Angular** has two methods to handle [view encapsulation](https://angular.io/guide/view-encapsulation). The default setting is `Emulated`, which works similarly to Vue under the hood. An alternative option is `ShadowDom`, which uses an actual shadow DOM for style scoping.

- **Svelte** implements its own [style scoping](https://svelte.dev/docs#style) mechanism.

---

Scoped CSS and styles encapsulation completely changed the way we author CSS. It fixes all the specificity-related problems, naming collisions, and the daunting task of figuring out unique names for the Semantic CSS classes. But most importantly, it has done it without introducing any compromises. It was **the end of global CSS**.

Another approach to encapsulate styling that I haven't mentioned here is **CSS-in-JS**. I skipped it because the topic of writing CSS in JavaScript deserves its own part within this series which we'll cover next in <LinkTo part={CURRENT_PART + 1} />.

<br />

**References**

- [CSS Modules: Welcome to the Future](https://glenmaddern.com/articles/css-modules) by Glen Maddern
- [The End of Global CSS](https://medium.com/seek-blog/the-end-of-global-css-90d2a4a06284#.4brb2kfit) by Mark Dalgleish
