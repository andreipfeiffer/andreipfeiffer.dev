import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { Figure } from "../../../../components/blog/figure";
import { TOC, LinkTo } from "../toc";

import Image from "next/image";
import img from './css-good-practices.png'

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 2;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

In the previous article of this series, <LinkTo part={CURRENT_PART - 1} />, we've witnessed how CSS preprocessors enabled us to reduce source code duplication while postprocessing optimized the output code.

During this part, we'll continue our journey to overcome the problems with CSS maintainability, focusing on **avoiding complex CSS selectors and specificity wars**. Therefore, let's explore some essential good practices introduced by various CSS pioneers:

- [Keeping specificity low](#keep-specificity-low)
- [Prefixing class names](#prefix-class-names)
- [Avoid applying styles on IDs](#avoid-applying-styles-on-ids)
- [Avoid type selectors](#avoid-type-selectors)
- [Avoid mimicking HTML structure](#avoid-mimicking-html-structure)
- [Avoid repetition](#avoid-repetition)
- [Avoid using `!important`](#avoid-using-important)

<Note title="Notes">
  <ul>
    <li>
      This is not at all a comprehensive list of practices, as the topic of
      maintainable CSS is pretty vast.
    </li>
    <li>
      As their name suggests, these are <strong>practices</strong>, not dogmas.
      Even if we treat them as rules, there are always understandable{" "}
      <strong>exceptions</strong>.
    </li>
  </ul>
</Note>

<Figure background={"#fff"} width="grid">
  <Image
    src={img}
    width="1920"
    height="845"
    alt="Timeline of scalable CSS evolution, pinpoiting the emergence of CSS good practices in 2005"
  />
</Figure>

## Keep specificity low

The <LinkTo part={1} hash="specificity-wars">specificity wars</LinkTo> are amongst the most dreadful problems to face as a UI developer. To avoid them, we must keep specificity as low as possible.

Sometimes we tend to be overzealous when writing CSS selectors instead of keeping them simple. For example, defining **overly specific CSS selectors** by abusing [descendant combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator) will result in high specificity while also coupling the targeted element with the HTML structure:

<!-- prettier-ignore-start -->
```css
/* ‚ùå BAD: overspecific selector (0.4.3 specificity) */
.header .main_menu ul li.item a.link {}
```
<!-- prettier-ignore-end -->

Let's analyze this code for a second:

- If there is a single `.main_menu` element on the page, then the `.header` selector is unnecessary. In case there is more than one `.main_menu`, we could use a different class name, like `.header_main_menu`, to differentiate them.
- The descendant selector `ul li.item` should not be necessary if all `a.link` elements are placed inside the `ul`. Thus we can skip this selector altogether.
- Last but not least, nobody should care that the `.link` is also an `a` element, so we can also remove the `a` selector.

<br />

Thus, the above selector could be easily simplified, while also reducing its specificity:

<!-- prettier-ignore-start -->
```css
/* üëç GOOD: less specific selector (0.2.0 specificity) */
.main_menu .link {}

/* ‚úÖ BEST: simple selector (0.1.0 specificity) */
.main_menu_link {}
```
<!-- prettier-ignore-end -->

<Subheading>Excessive nesting with CSS preprocessors</Subheading>

With CSS preprocessors it's even easier to create high specificity, thanks to their nesting feature. Unfortunately, we often use **excessive nesting**, which is way too overused and creates significant scalability problems.

<SideBySide left={{lang: "SCSS", file: "style.scss (source)"}}  right={{lang: "CSS", file: "style.css (output)"}}>

```scss
// ‚ùå excessive nesting
.main_menu {
  ul {
    li {
      .link {
      }
    }
  }
}
```

```scss
// ‚ùå overspecific CSS output
.main_menu {
}
.main_menu ul {
}
.main_menu ul li {
}
.main_menu ul li .link {
}
```

</SideBySide>

<br />

We could easily reduce the specificity of the output CSS selectors by limiting the number of nesting levels:

<SideBySide left={{lang: "SCSS", file: "style.scss (source)"}}  right={{lang: "CSS", file: "style.css (output)"}}>

```scss
// üëç less nesting
.main_menu {
  ul {
  }
  li {
  }
  .link {
  }
}
```

```scss
// üëç lower specificity output
.main_menu {
}
.main_menu ul {
}
.main_menu li {
}
.main_menu .link {
}
```

</SideBySide>

<br />

<Subheading>So, how low is "low enough"?</Subheading>

Keeping specificity low is definitely going to be helpful in the long run. But what exactly does "low" mean? How "low" should we keep it, and when does it become "too high"?

A rule of thumb used to say that _CSS selectors should not have more than 2 descendants or levels of nesting_. Thus, it's common sense to say that:

- use **a single CSS class** as the goto option: `.main_menu_link`;
- use **1 descendant** when overriding is necessary: `.dark-theme .main_menu_link`;
- use **2 descendants only in extreme scenarios** when the previous rules don't apply.

## Prefix class names

In a previous part of this series, we talked about potential <LinkTo part={1} hash="naming-collisions">naming collisions</LinkTo>. Since CSS doesn't natively support namespacing, we could use a workaround by **adding a prefix** related to the project to each CSS class name that we define. Prefixed classes would significantly reduce the collision chance with external styles.

The prefix should be concise. For example, I could use `pf-`, the first 2 letters from my last name, as a prefix for the class names defined for this website.

<!-- prettier-ignore-start -->
```css
/* ‚ùå could be potentially overridden */
.header {}

/* üëç less likely to be overridden */
.pf-header {}
```
<!-- prettier-ignore-end -->

<Subheading>Exceptions</Subheading>

There are many situations where prefixing is not necessary, namely with utility classes or descendant elements:

<!-- prettier-ignore-start -->
```css
/* üëç utility classes */
.rounded {}

/* üëç descentant elements */
.pf-header .logo {}
```
<!-- prettier-ignore-end -->

<Note>
  Most well-written libraries use prefixes for their styles to avoid naming
  collisions when included in actual projects.
</Note>

## Avoid applying styles on IDs

Sometimes _we might think_ that a particular HTML block will only be displayed a single time on the page, so we could be inclined to use [ID selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors) for styling. Such examples might include the **page's header**, the **contact form**, or the **product details page**. However, two major problems could occur when we apply styles on ID selectors.

<Subheading>1. Unexpected overridden styles</Subheading>

Let's consider an HTML block called `.profile`, which contains an `.image` element. This block of content is used only on a specific page, for instance `post-listing.html`:

<SideBySide left={{lang: "HTML", file: "post-listing.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html
<div class="profile">
  <img src="..." class="image" />
</div>
```

```css
.profile .image {
  border: 1px black solid;
}
```

</SideBySide>

<br />

At some point, we want to reuse the `.profile` content block on a different page. Unfortunately, that page already contains an `.image` element, which is used inside an **ID selector** in CSS:

<SideBySide left={{lang: "HTML", file: "post-details.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html{4}
<div id="post-details">
  <img src="..." class="image" />

  <!-- include the .profile block here -->
</div>
```

```css
/* IDs have higher specificity than classes */
#post-details .image {
  border: 10px grey solid;
}

.profile .image {
  /* these style will get overridden */
  border: 1px black solid;
}
```

</SideBySide>

<br />

In these circumstances, the `.profile .image` styles will get overridden by the more specific `#post-details .image` selector. We could change the class names to avoid collisions, but the fundamental problem still remains: **reusing HTML blocks could render different styles, depending on where we include them**.

Any non-deterministic behavior is potentially a critical problem when thinking about long-term maintainability.

<Subheading>2. Lack of reusability</Subheading>

The last time I checked, [foreseeing](<https://en.wikipedia.org/wiki/Foresight_(psychology)>) future needs is very debatable. In addition, my own past experiences strongly support that we are generally bad when making predictions.

It happened to me so many times to think that _"we'll never have more than one Contact Form"_, only to find out one week later that we needed to add a _Subscribe Form_, which looked mostly as the existing _Contact Form_.

<!-- prettier-ignore-start -->
```css
/* ‚ùå code smell which proves that we cannot foresee the usage of code blocks */
#contact-form,
#subscribe-form {}
```
<!-- prettier-ignore-end -->

<br />

Therefore, to avoid any of the problems mentioned above, we should avoid applying styles on ID selectors altogether and use classes instead:

<!-- prettier-ignore-start -->
```css
/* ‚ùå avoid using ID selectors in CSS */
#contact-form {}

/* ‚úÖ use classes instead */
.contact-form {}
```
<!-- prettier-ignore-end -->

<Note>
  It's perfectly fine to use IDs for other purposes, like{" "}
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#linking_to_an_element_on_the_same_page">
    anchor links
  </a>
  , for example. But, we should avoid using them in CSS selectors.
</Note>

## Avoid type selectors

CSS [type selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors) match HTML elements by their tag name. The problem is that using this approach will **create a coupling between the markup and the styles**. As a result, changing the markup will unexpectedly break the styles.

Let's consider the following scenario:

<SideBySide left={{lang: "HTML", file: "index.html"}}  right={{lang: "CSS", file: "style.css"}}>

```html
<div class="card">
  <h2>...</h2>
</div>
```

```css
.card h2 {
}
```

</SideBySide>

- we have a `.card` element that contains a title placed inside an `h2`;
- we apply the styles using the `.card h2` selector;
- for some reason, somebody needs to replace the `h2` with an `h3`, which is a trivial change and we shouldn't be concerned of breaking anything;
- without knowing that there are styles applied to the `h2` element that we need to update as well, there's a high chance of introducing regressions;
- debugging such a problem could be cumbersome because the styles are applied implicitly, not explicitly.

<br />

Thus, the **styles will be coupled with the markup**. We cannot change the markup without updating the styles as well. Whenever we have a **tight coupling** between parts of code that should be modified independently, without affecting one other, we have a scalability problem.

<!-- prettier-ignore-start -->
```css
/* ‚ùå avoid HTML tag names */
.card h2 {}

/* ‚úÖ classes are way more flexible */
.card .title {}
```
<!-- prettier-ignore-end -->

<br />

The solution is quite simple: **avoid targetting HTML tags in CSS and use classes instead**. This will create an explicit dependency between the styles and the markup, being easy to debug. In addition, changing the markup will not affect the styles.

<Subheading>Exceptions</Subheading>

I still follow this rule pretty strictly, even nowadays. However, there are a few exceptions where type selectors are helpful or even required:

1. **Resetting or normalizing CSS** implicit styles;

2. **Styling dynamic content from a headless CMS** because we get plain HTML content without any class names. Thus, we must target elements by their type, for instance, `.blog_post h2`.

## Avoid mimicking HTML structure

Sometimes we might be inclined to define CSS selectors based on an existing HTML structure. Similar to the previously described problem, mimicking the HTML structure in our CSS code will once again couple the markup with its styles, thus producing **rigid CSS code**.

<!-- prettier-ignore-start -->
```scss
// ‚ùå BAD: unneeded "nav" ancestor
.main_menu nav .link {}

// üëç BETTER: less structure dependent
.main_menu .link {}

// ‚úÖ BEST: using a single class
.main_menu_link {}
```
<!-- prettier-ignore-end -->

<br />

Another related scenario is using **strict combinator selectors** such as [child combinator](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator) or [adjacent sibling combinator](https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator), also creating tight coupling. However, I've rarely encountered a scenario that couldn't be implemented with CSS classes alone, so we should avoid these types of selectors.

<!-- prettier-ignore-start -->
```css
/* ‚ùå What if we need to wrap the logo in a <div />? */
.header > .logo {}

/* ‚ùå What if we need to display the label first? */
.checkbox + .label {}
```
<!-- prettier-ignore-end -->

## Avoid repetition

Before the concept of components became popular, we had much more repetition in our code, CSS making no exception. The tendency is to add the required CSS rules for a specific feature without looking back and analyzing whether an abstraction could be extracted and reused. For instance:

```css{4,9,17}
.product-card {
  border-radius: 10px;
  border: 1px #aaa solid;
  padding: 16px;
  background: #fafafa;
}

.contact-form {
  padding: 32px;
  border-radius: 10px;
  border: 1px #aaa solid;
  background: #fafafa;
}

.shopping-cart-list {
  border-radius: 10px;
  padding: 24px;
  border: 1px #aaa solid;
  background: #fafafa;
}
```

The only difference between the CSS selectors displayed above is the `padding` rule, while everything else is the same. To avoid this repetition, we can extract the common styles into a separate abstract class, employing the DRY principle:

```css{1-5}
.box {
  border-radius: 10px;
  border: 1px #aaa solid;
  background: #fafafa;
}

.product-card {
  padding: 16px;
}

.contact-form {
  padding: 32px;
}

.shopping-cart-list {
  padding: 24px;
}
```

The `.box` class can be easily composed with other classes, making it **more flexible**. In addition, there's only one source of truth, so whenever we need to change the styles, we'll update a single class.

<br />

We could go a step further and create a bunch of **utility classes**, like generic styles for [accessible hidden content](https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html) or custom styles that could encapsulate even a single CSS rule:

<!-- prettier-ignore-start -->

```css
.rounded {
  border-radius: 10px;
}
.bordered {
  border: 1px #aaa solid;
}

.color-primary {}
.color-secondary {}
```
<!-- prettier-ignore-end -->

Such utility classes are still widely used today in most CSS frameworks. Consequently, they also gave birth to dogmatic approaches such as <LinkTo part={5}>Atomic CSS</LinkTo>, which takes the practice of _one CSS rule per class_ to the extreme.

## Avoid using `!important`

At some point, we might be tempted to use `!important` as an attempt to fix the specificity wars. But, unfortunately, it's a losing battle. Many of us tried to make it work, but none of us succeeded. Even [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#:~:text=Using%20!important%2C%20however%2C%20is%20bad%20practice%20and%20should%20be%20avoided) documents it as a **bad practice**.

If we use `!important` to fix the specificity wars, it won't take long until the **!important wars** start. At some point, we'll need to override already `!important` rules, which is possible but disastrous.

> When we end up overriding an `!important` CSS rule, we hit rock bottom regarding CSS maintainability!

<Subheading>Exceptions</Subheading>

Imagine the irony: even such an important good practice, to avoid using `!important`, has a few important exceptions worth mentioning:

1. **Overriding 3rd party styles** when they have high specificity, which is cumbersome to override using conventional methods.

2. **Defining abstract utility classes** such as `.bold` or `.align-center`, because they could be easily overridden by accident.

---

## The problems with good practices

Once we learn and understand all these practices, it should be fairly easy to apply them, right? Unfortunately, it's not a trivial task at all.

- There is **no official comprehensive guide** on how to write maintainable CSS. I've only covered a few of the essential practices, but there are [so many more](http://khaidoan.wikidot.com/css-best-practices) to consider.
- Some of the **practices don't apply equally** to every project, with every team. Also, developers tend to be very opinionated, so we rarely reach a consensus regarding a specific set of rules.
- Being so many practices and most of them quite debatable, they are **cumbersome to learn and teach**.
- As we've seen, there are plenty of **exceptions** that apply to every practice. It's often quite challenging to draw a line when it is acceptable to break the rule.
- Most of the important good practices are **impossible to enforce**. The only weapon is constant code review, trainings, and mentoring.
- Once we have an existing large application written without these practices in mind, they become **tough to introduce onto an existing code base**. Changing CSS, in general, is a fragile task, so most developers avoid touching it.
- Last but not least, **good practices don't scale**! The larger the code base, the more burdensome the maintenance will become.

<br />

In the upcoming chapter, <LinkTo part={CURRENT_PART + 1} />, we'll explore various **methodologies** and **architectures**, built on top of many of the good practices that we've covered here, which provide a structured and cohesive set of principles and rules.

<br />

**References**:

- [CSS tips and tricks](https://www.456bereastreet.com/archive/200503/css_tips_and_tricks_part_1/) by 456 Berea Street
- [Our (CSS) best practices are killing us](http://www.stubbornella.org/content/2011/04/28/our-best-practices-are-killing-us/) by Nicole Sullivan
- [Code smells in CSS](https://csswizardry.com/2012/11/code-smells-in-css/) by Harry Roberts
