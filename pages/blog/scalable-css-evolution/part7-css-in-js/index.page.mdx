import { BlogPost } from "../../../../components/blog/blog_post";
import { Subheading } from "../../../../components/blog/subheading";
import { SideBySide, Side } from "../../../../components/blog/sidebyside";
import { Status } from "../../../../components/blog/status";
import { Note } from "../../../../components/blog/note";
import { TOC, LinkTo } from "../toc";

import { meta } from "./meta";
export { meta } from "./meta";
const CURRENT_PART = 7;

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

<TOC current={CURRENT_PART} />

In the previous article of this series <LinkTo part={CURRENT_PART - 1} /> we've covered different methods to scope our styles to the component they belong to and not leak into the global namespace, or influence other components.

It's worth mentioning that styles encapsulation was also one of the core goals of CSS-in-JS. However, CSS-in-JS means much more than just styles encapsulation. In this article we'll take a closer look at:

- [**The purpose of CSS-in-JS**](#the-purpose-of-css-in-js);
- [**Dead code elimination**](#dead-code-elimination);
- How to [**easily share design tokens**](#shared-design-tokens);
- How to easily [**navigate through code**](#code-navigation);
- And lastly, some common [**CSS-in-JS myths**](#css-in-js-myths).

## The purpose of CSS-in-JS

Before jumping into the main content, I think it's really important to answer the question _"Why does CSS in JavaScript even exist?"_ and understand its purpose in this world.

CSS-in-JS was introduced at the end of 2014, before CSS Modules or other popular style encapsulation approaches were available. There are 2 known pioneers of CSS-in-JS, namely [Christopher Chedeau](http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html) from Facebook and [Oleg Isonen](https://oleg008.medium.com/the-important-parts-131dda7f6f6f) author of [JSS](https://cssinjs.org/).

<br />

Because CSS scoping was not the status quo at that time, there is some _overlap between CSS-in-JS and CSS Modules_ in regard to the problems that they solve:

- **Styles encapsulation** is a core feature of any CSS-in-JS solution.
- **Explicit dependencies** enable easier reasoning about the code, because the classes applied in the markup don't reference <LinkTo part={1} hash="implicit-dependencies">implicit CSS classes</LinkTo> that should be available somewhere in the code base. Instead, there is an explicit `import` of the styles, and the class names explicitly reference the imported styles.
- **Avoiding zombie code** is mainly a consequence of having explicit dependencies. Since each component imports its own styles, when we remove the component or don't import it anymore, the styles with not be included neither.

This might be one of the reasons that many developers consider CSS-in-JS a useless technology, because all their problems are already solved by CSS Modules (or other types of style encapsulation) and probably a CSS preprocessor.

<br />

However, CSS-in-JS tried to solve other problems as well, beyond what CSS Modules or any other approach could achieve:

- **Dynamic styling** mostly required in highly interactive applications is incredibly easy to implement. **State-based styling** like toggling a styles or implementing multiple component variations can also be achieved with regular CSS also, but with a greater effort. **User-defined styles** on the other hand cannot be implemented using CSS alone, but also require JavaScript, fitting like a glove with CSS-in-JS.
- **Sharing design tokens** from (S)CSS to JavaScript or vice-versa is technically possible, but requires a lot of boilerplate, is error prone, amd most importantly it's not type checked with regular CSS. With CSS-in-JS we can share not only `constants`, but also `types`, `functions`, or any other JS code.
- **Type-checking** is not possible with regular CSS. If a style is missing or a class name misspelled, no tool will help us debug the problem. Having the styles written in JavaScript unlocks the power of type-checking. If we put TypeScript on top it gets even better.

<br />

In addition, CSS-in-JS unlocked other features that turned out to be pretty easy to implement, having all style definitions in JavaScript:

- **Theming** and especially **runtime theme toggling** became trivial with CSS-in-JS.
- **Critical CSS extraction** for Server-Side Rendered pages is implemented in all CSS-in-JS libraries that support SSR.
- **Lazy loading styles** comes out-of-the-box with dynamically loaded components.
- **Colocated styles** within the component file, similar to [React Native StyleSheets](https://reactnative.dev/docs/stylesheet), [Vue.js SFC](https://vuejs.org/v2/guide/single-file-components.html) or [Angular Components](https://angular.io/guide/component-styles) turns out to be very convenient.

## Dead code elimination

As we've seen, removing unused code also works with CSS Modules, it's a feature specific to CSS-in-JS. However, with CSS-in-JS we get more fine-grained and efficient results:

- with CSS Modules, dead code elimination works at **component or file level**;
- with CSS-in-JS, dead code elimination works at **element or style level**.

<br />

Consider the following implementation with CSS Modules:

<SideBySide left={{lang: "JSX", file: "footer.jsx (with CSS Modules)"}}  right={{lang: "CSS", file: "footer.module.css"}}>

```tsx
import styles from "./footer.module.css";

export function Footer() {
  return (
    <footer>
      <p className={styles.contact}>Get in touch</p>
      {/* <p className={styles.copyright}>Copyright 2021</p> */}
    </footer>
  );
}
```

```css
.contact {
  color: "black";
}

/* even if we don't use this class, it will be bundled */
.copyright {
  color: "grey";
}
```

</SideBySide>

Now, let's imagine that at some point we'll remove some elements from the component, that also reference styles. Any unused styles from an imported CSS Module will be bundled also, as there is no trivial way to make sure that a particular class is not used in the code base.

As long as the `<Footer />` component is imported somewhere the entire `.css` will also be bundled. However, if the `<Footer />` component is not needed anymore, thus not imported at all, then the `.css` will also be skipped.

<br />

<!-- prettier-ignore-start -->

<Side header={{ lang: "JSX", file: "footer.jsx (with CSS-in-JS)" }}>

```tsx
import { css } from "css-in-js-library";

const contact_styles = css({ color: "black" });
const copyright_styles = css({ color: "grey" });

export function Footer() {
  return (
    <footer>
      <p className={contact_styles}>Get in touch</p>
      {/* <p className={copyright_styles}>Copyright 2021</p> */}
    </footer>
  );
}
```

</Side>

<!-- prettier-ignore-end -->

With CSS-in-JS on the other hand we have a more direct reference between styled definition and their usage. In our example, `copyright_styles` is just a JavaScript constant. The compiler can _see_ that it is not used, so it will be ignored.

In addition, linters can highlight that we have [unused identifiers](https://eslint.org/docs/2.0.0/rules/no-unused-vars) that can be safely removed. Removing unused styles is dead simple.

## Shared design tokens

[Design tokens](https://design.infor.com/product/design-tokens) are fundamental building blocks of any **design system**. But even when working on smaller projects that don't require a robust design system, we'll surely need to define and reuse a bunch of variables (or constants) like **colors** or **media query breakpoints** just to name a few.

<br />

_Ok, but we can already do that with [CSS custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) or [SASS variables](https://sass-lang.com/documentation/variables)._  
_**Why would we need to share them?**_

There are multiple reasons for sharing values to be used both in CSS and JavaScript. Some use-cases that I have encountered include:

- using breakpoint values with [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) for [Responsive Web Design](https://web.dev/responsive-web-design-basics/) (RWD) or [Adaptive Web Design](https://webflow.com/blog/adaptive-vs-responsive-design);
- passing the same colors used in CSS to 3rd party libraries that require initialization from JavaScript;
- reusing animation durations with libraries such as [CSSTransition](http://reactcommunity.org/react-transition-group/css-transition) from React Transition Group package, etc.

<br />

<Subheading>Using (S)CSS as the source of truth</Subheading>

One approach is to define the variables in our (S)CSS files, either as _CSS custom properties_, _SASS variables_, or [_CSS Modules @values_](https://github.com/css-modules/postcss-modules-values) and expose them to be importable in JavaScript.

Keeing it short, there are technical solutions to [share variables from CSS to JavaScript](https://www.falldowngoboone.com/blog/share-variables-between-javascript-and-css/) using any styling method.

<Subheading>Using JS as the source of truth</Subheading>

An alternative is to store the variables as JS variables or objects and to expose them to (S)CSS. This approach looks more convenient if we think about [Universal Design Tokens](https://udt.design/) (UDT), which also suggest using JSON as an interchangeble data format. And we all know that JSON plays nicely with JavaScript.

Again, there are technical solutions for exporting JS/JSON objects to [SASS variables](https://github.com/planetflash/sharing_variables_js_sass), [CSS Modules](https://github.com/macropodhq/postcss-constants), or [CSS custom properties](https://css-tricks.com/updating-a-css-variable-with-javascript/).

<Subheading>
  <Status type="err" />
  Limitations
</Subheading>

As you probably saw from the examples, any solution we choose is not straightforward, not trivial. Heck, they look more like hacks, not solid and elegant approaches. In addition:

- **Code editors cannot display suggestions or autocomplete** for (S)CSS (Modules) variables, making them difficult to discover. There are some extentions that support this, but are pretty flawed from my experience.
- CSS (Modules) **completely lack type-safety** meaning that any refactoring requires manual effort and testing. The tools cannot help us to detect any misspelled or missing variables.

<br />

It's needless to say that with CSS-in-JS, sharing anything between JavaScript code and styles, which are also defined in JavaScript, becomes simple and straightforward.

## Code navigation

As we've all probably experienced by now, we read, debug, and change code more often than writting it. That's why navigating through code easily and effortlessly is important.

Consider a simple task as _exploring what CSS rules are defined for a particular CSS class applied to an element_:

- using plain (S)CSS requires us to **copy the CSS class**, **paste it into a find tool** and append a dot `.` so we'll find its definition;
- with CSS Modules the process is the same, even though we're explicitly importing the styles.

<Subheading>
  <Status type="ok" />
  Go to Definition
</Subheading>

With CSS-in-JS, all styles are JavaScript constants. By pressing `Ctrl + click` (`CMD + click` on Mac) or selecting [Go to Definition](https://code.visualstudio.com/Docs/editor/editingevolved#_go-to-definition) from the context menu, the editor will instantly take us to the style definition.

<Subheading>
  <Status type="ok" />
  Find all References
</Subheading>

The opposite task is also simple. To discover where is a style (or any other variable) referenced, we can `Right-click` on the identifier and select [Find All References](https://code.visualstudio.com/updates/v1_29#_references-view) from the context menu.

## CSS-in-JS myths

We need to debunk a few myths and misconceptions regarding CSS-in-JS, so let's explore _"What CSS-in-JS is not about"_.

<Subheading>CSS-in-JS is not only for React</Subheading>

While it's true that some CSS-in-JS libraries are specifically built for React and cannot be used without it, the large majority of them are [framework agnostic](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#react-specific-or-framework-agnostic). So, CSS-in-JS libraries can be used without React as well.

<!-- prettier-ignore-start -->

```jsx
// consider this the API of a typical CSS-in-JS library
import { css } from "css-in-js-library";

// this will return a string representing a unique CSS class name
const title_styles = css({ color: "blue" });

// the class name can be applied as any regular CSS class
const template = `<h1 class="${title_styles}">Title</h1>`
```

<!-- prettier-ignore-end -->

What _is true_, on the other hand, is that there aren't notable or popular implementations of CSS-in-JS libraries in other frameworks, at least as of September 2021.

<Subheading>CSS-in-JS doesn't mean inlining styles</Subheading>

None of the existing CSS-in-JS libraries use inline styles as output.

What _is true_ however, is that there were a few libraries like [Radium](https://formidable.com/blog/2019/radium-maintenance/) and [Glamor](https://github.com/threepointone/glamor) that used inline styles, but both have been discountinued.

It is a known fact that inline styles had limited support for CSS syntax, being impossible to define certain pseudo classes, pseudo-elements, or media queries. Not to mention that common pseudo classes like `:hover` or `:focus` required reinvention of the wheel, by attaching DOM event listeners and triggering style updates using JavaScript.

<Subheading>CSS-in-JS supports all CSS syntax</Subheading>

All _modern_ CSS-in-JS libraries support the full CSS syntax.

I have [analyzed more than 10 libraries](https://github.com/andreipfeiffer/css-in-js/), focusing mostly on features such as **pseudo classes and elements**, **media queries**, and **keyframe animations**.

As far as my knowledge and understanding goes, there aren't any CSS syntax or features that are not supported by CSS-in-JS.

<Subheading>CSS-in-JS is not equivalent with "styled components"</Subheading>

[styled-components](https://styled-components.com/) is only one of the libraries that uses CSS-in-JS. It is indeed a very popular one.

Furthermore, they also introduced a new way to apply the styles written in JS to the desired HTML elements, a technique that's also called [**styled components**](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#using-a-styled-component).

<!-- prettier-ignore-start -->

```jsx
// consider this the API of a typical CSS-in-JS library
import { styled } from "css-in-js-library";

const Title = styled("h1")({
  color: "blue"
});
```

<!-- prettier-ignore-end -->

If you're not confused enough yet, other libraries have also used this approach, or added support for this syntax, because of its rising popularity. But in the end, **a styled component is only a technique to attach CSS styles to a DOM element or an existing component**.

<Subheading>CSS-in-JS doesn't force writing "styles as objects"</Subheading>

There are plenty of CSS-in-JS libraries that support the [tagged templates syntax](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#tagged-templates-syntax), which allows developers to write styles exactly like regular CSS syntax, with `kekab-case` property names.

What _is true_ is that most of the libraries (also) support the [object styles syntax](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#object-styles-syntax) because it's simpler, more lightweight, and doesn't require additional parsing.

<Subheading>CSS-in-JS is not for CSS ignorants</Subheading>

CSS-in-JS is not for developers that don't know CSS. If you don't know CSS, you won't be able to write CSS-in-JS neither.

> CSS-in-JS is simply a technique that helps us write scalable and maintainable CSS.

### Static CSS Extraction

There are a lot of complaints about CSS-in-JS regarding its **runtime overhead**, because it requires additional code to evaluate, inject and update styles in the browser. Indeed, this overhead exists and varies between `1.1 kB` and `18.2 kB` gzipped & minified, based on my own [analysis](https://github.com/andreipfeiffer/css-in-js/blob/main/README.md#overview).

However, there are some libraries that implement [static CSS file extraction](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#static-css-file-extraction), generating a real `.css` file at built time, which can be included in our document as any regular CSS file. This technique adds **zero runtime cost**. Thus, we get all te benefits of CSS-in-JS regarding the development experience and the benefits of regular stylesheets that we get from using CSS Modules, CSS preprocessors, or simply plain CSS.

<Note>
  It's important to understand that fewer transferred bytes doesn't imply faster
  load metrics like <strong>First Paint</strong> or{" "}
  <strong>Time To Interactive</strong>. For more details, checkout this debate
  regarding performance between{" "}
  <a href="/blog/css-in-js-styles-output">
    runtime stylesheets and static css extraction
  </a>
  .
</Note>

### Atomic CSS-in-JS

At the end of <LinkTo part={5} /> I mentioned that _"we will revisit [Atomic CSS] in a future chapter"_. Atomic CSS is also possible using CSS-in-JS, hence the term [Atomic CSS-in-JS](https://css-tricks.com/a-thorough-analysis-of-css-in-js/#atomic-css).

Now, the beautiful part about Atomic CSS-in-JS is that we don't have to learn the specific DSL of a particular library. We write the styles like we normally do with CSS-in-JS.

It's the library that takes care at built time to **generate atomic CSS classes only for the CSS rules that were actually used** in our code.

---

So, let's recap what CSS-in-JS provides:

- styles encapsulation, so **we don't need CSS Modules** anymore;
- variables and contextual styles, like the nesting and parent selector, **making CSS preprocessors obsolete**;
- atomic classes, so **no need to use utility-first frameworks**;
- static stylesheets, so we have **no reason not to use CSS-in-JS**.

<br />

But, there's more. So far we only talked about CSS-in-JS. But what if we replace JavaScript with TypeScript?

In the next article <LinkTo part={CURRENT_PART + 1} /> we'll see how CSS-in-JS paired with TypeScript can provide the benefits of type safety for our CSS code.

<br />

**References**:

- https://www.youtube.com/watch?v=75kmPj_iUOA
- https://medium.com/dailyjs/what-is-actually-css-in-js-f2f529a2757
- https://github.com/stereobooster/css-in-js-101
- https://github.com/andreipfeiffer/css-in-js
- https://sebastienlorber.com/atomic-css-in-js
- https://ryantsao.com/blog/virtual-css-with-styletron
