import BlogPost from "../../../components/blog_post";
import Link from "next/link";

export const meta = {
  title: "Empty objects initialization with TypeScript",
  date: "2020-12-27",
  tags: ["javascript", "typescript", "objects", "types"],
  category: "javascript",
  // @todo add cover
  // cover: "/images/blog/cover-definition-lists-with-column-flow-grid-layout.png",
};

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

In the following post we'll examine multiple methods to initialize empty objects in TypeScript, which is something you'll probably have to deal with in any application that has some form of state management when:

- populating a form, for creating new content;
- resetting an object to its initial, or empty state;
- passing a dummy object in your tests.

<br />

Of course, there is a straighforward way to do this:

1. first **define the type**;
2. then **initialize the object** based on the previously defined type.

```tsx
// define the type
type Article = {
  title: string;
  date: Date;
  author_id: number;
};

// initialize the empty object
const EMPTY_ARTICLE: Article = {
  title: "",
  date: new Date(),
  author_id: 0,
};
```

<br />

This is convenient for a few simple objects, but it might become cumbersome for more complex ones:

- you get the feeling that you write **duplicated code**, once when defining the type, second when you initialize the object;
- **deeply nested objects** become a pain in the butt to initialize;

```tsx
type Order = {
  id: number;
  address: Address /* deeply nested type */;
};

type Address = {
  country: Country /* nested type */;
  city: City /* nested type */;
  street: string;
};

type Country = { id: number; name: string; code: string };
type City = { id: number; country_id: number; name: string };

const EMPTY_ORDER: Order = {
  id: 0,
  address: {
    country: {
      id: 0,
      name: "",
      code: "",
    },
    city: {
      id: 0,
      country_id: 0,
      name: "",
    },
    street: "",
  },
};
```

<br />

So let's examine a couple of alternative approaches, that might be easier to use:

- using **type assertions**;
- using **typeof type operator**.

**Important**: To not get your hopes too high, none of these alternatives is perfect, so we'll discuss all their trade-offs in detail.

## Using type assertions

```tsx
type Article = {
  title: string;
  date: Date;
  author_id: number;
};

const EMPTY_ARTICLE = {} as Article;
```

One quick and dirty solution to our problem is to trick the type system to accept an empty object as the needed type. As tempting as it might be, because of how easy it is to use, **this approach introduces some huge problems**:

### Flawed type-checking

Our code will not be properly type-checked because we're lying to our type system. We're assuring it that all expected properties are present, with their expected types, when in fact, they are missing:

```tsx
typeof EMPTY_ARTICLE.title;
// at compile time: "string"
// at runtime: "undefined"
```

### Runtime exceptions

Certain runtime exceptions will definitely occur, because we're not initializing our object with the expected properties. So, whenever we're trying to call any methods on the object's properties, or when accessing deeply nested properties, we'll get an error:

```tsx
EMPTY_ARTICLE.title.length;
// at compile time: no error
// at runtime: Cannot read property "length" of undefined
```

We might find ourselves polluting our code with defensive methods, like optional chaining, to avoid runtime errors, which is a code smell, I would say:

```tsx
EMPTY_ARTICLE?.title?.length;
```

<br />

**WARNING**:  
Using type assertions **is definitely not recommended**, unless you understand all the trade-offs and they're not a problem for your use-case. I've presented it only for educational reasons, to highlight its downsides.

---

## Using the `typeof` type operator

There is another approach we can use, that I've heard from [Martin Hochel](https://twitter.com/martin_hotell). Instead of defining the type first, and then perform the initialization, we can do it the other way around:

1. first, **initialize the object**;
2. then, use TypeScript's [`typeof`](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html) operator to **infer the type**.

```tsx
// initialize the empty object
const EMPTY_ARTICLE = {
  title: "",
  date: new Date(),
  author_id: 0,
};

// infer the type
type Article = typeof EMPTY_ARTICLE;
```

TypeScript is able to infer a wide range of types using this approach: **numbers**, **strings**, **classes** (built-in and custom), **enums**, **arrays** (if they are not empty), **nested object** structures.

But, there are some limitations when you have to deal with more specific types.

### Limitation 1: Union types

**Union types** cannot be inferred, because when you initialize the object, the value that you specify is only a subset of the Union type that you expect. TypeScript has no way to guess the other values.

```tsx
const EMPTY_FILTER = {
  direction: "up",
};

type Filter = typeof EMPTY_FILTER;
// expected type: { direction: "up" | "down" }
// inferred type: { direction: string }
```

We can explicitly specify the type, using type assertions:

```tsx{2}
const EMPTY_FILTER = {
  direction: "up" as "up" | "down",
};

type Filter = typeof EMPTY_FILTER;
// inferred type: { direction: "up" | "down" }
```

### Limitation 2: Optional types

Another important issue that you'll probably face, is that you cannot properly type **optional properties**. TypeScript cannot infer based on a single JavaScript value, that it can also be `undefined`.

Similar to the problem mentioned above, we can overcome this limitation by using type assertions to explicitly specifying a Union type that also contains `undefined`:

```tsx
const EMPTY_FILTER = {
  direction: "up" as "up" | "down" | undefined,
};
```

### Limitation 3: Nested types

If you have nested types, the structure will be properly inferred, but the nested type will not.

Consider the following use-case, where the `Address` contains a nested `Country`. The structure of the `Country` type will be properly inferred inside the `Address` type, but we will see the **type structure**, not the **type alias**:

```tsx
const EMPTY_COUNTRY = { id: 0, name: "" };

type Country = typeof EMPTY_COUNTRY;

const EMPTY_ADDRESS = {
  street: "",
  country: EMPTY_COUNTRY,
};

type Address = typeof EMPTY_ADDRESS;
// expected type: { street: string, country: Country }
// inferred type: { street: string, country: { id: number, name: string } }
```

<br />

**Note**: In this case, using a type assertion like **`country: EMPTY_COUNTRY as Country`** won't work, as the type system will not infer the nested type as expected (at least not in TypeScript 4.1).

However, this limitation is not a functional problem, but more of an esthetic issue, that impacts the way you vizualize the type in your code editor. Seeing the entire list of properties can obscure the overview of complex types that contains many properties or nested structures.

### Limitation 4: Array types

Arrays are properly inferred, but only if they contain at least one element. If we use an empty Array, TypeScript cannot guess what kind of elements will the Array contain, so we need to use **type assertions** to instruct the type system:

```tsx
const EMPTY_USER = {
  ...,
  badges: ["novice"] /* inferred type: string[] */,
  friends_ids: [] as number[],
};

type User = typeof EMPTY_USER;
```

However, this does not work with custom types, that are created using the `typeof` operator. This is probably a consequence of the nested types limitation, previously mentioned:

```tsx
const EMPTY_ADDRESS = { city_id: 0, street: "" };

type Address = typeof EMPTY_ADDRESS;

const EMPTY_USER = {
  address_list: [] as Address[],
};

type User = typeof EMPTY_USER;
// expected type: { address_list: Address[] }
// inferred type: { address_list: { city_id: number, street: string }[] }
```

## Recap

Empty objects might not be something that you use everyday. But in case you have to deal with lots of complex types, that require initialization with some sort of empty data, it's good to know what options do we have at our disposal:

- Using **type assertions** is the easiest option, but it's **not recommended**, as it introduces flawed type-checking and runtime exceptions.
- Using the **`typeof` operator** is a better option, but it has **some limitations**. However, it can be helpful if we deal with simpler types.
- Explicitly creating the empty object based on a previously defined type is more verbose than the previous options, but also the most suitable when dealing with nested types, union types, or other more specific types.
