import { BlogPost } from "../../../components/blog/blog_post";
import { Subheading } from "../../../components/blog/subheading";
import { Status } from "../../../components/blog/status";
import { Figure } from "../../../components/blog/figure";

import img1 from "./ui-api1.png";
import img2 from "./ui-api2.png";
import img3 from "./ui-api3.png";
import img4 from "./ui-api4.png";
import Image from "next/image";

import { meta } from "./meta";
export { meta } from "./meta";

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

Almost all user interfaces that I've developed, with a few exceptions, dealt with data served from an HTTP server, usually a RESTful or a GraphQL API.

<Figure background={"#fff"}>
  <Image
    src={img1}
    width="1818"
    height="511"
    alt="Typically, User Interfaces manage data using web APIs"
  />
</Figure>

During development, there are multiple methods to connect these interfaces with their corresponding APIs. The ones that I've used so far are:

- connecting to a [**remote development server**](#remote-development-server)
- setting up a [**local development environment**](#local-setup)
- configuring a local [**fake API**](#fake-api)

<br />

Let's explore each of them in more detail to discover their strong points and limitations.

## Remote development server

Connecting to a remote development server is probably the most convenient method for a UI/Front-End developer because it requires no effort on their side. The entire effort relies on the infrastructure team, which has to deploy the API on a secured public URL.

It's important to understand that this lack of effort also means a lack of flexibility. We're relying solely on external resources beyond our control.

<Figure background={"#fff"}>
  <Image
    src={img2}
    width="1818"
    height="870"
    alt="A User Interface connected to a remove development server"
  />
</Figure>

<Subheading>
  <Status type="ok" /> No local setup required
</Subheading>

It doesn't get any easier than this. The only thing we need to do as UI developers using this approach is to **point the outgoing requests to the remote API address**. No local setup is required, so we can focus exclusively on the UI.

<Subheading>
  <Status type="ok" /> Shared data
</Subheading>

Another benefit is that all the **stored data is shared with all the team members** working with that API. This means that all team members work with the same application state, being able to easily reproduce any potential bug.

Keep in mind that changing or removing any data will impact anyone using that API, so communication between team members is essential.

<Subheading>
  <Status type="err" /> Infrastructure dependent
</Subheading>

One limitation of this approach is that it's not trivial to **deploy different branches** on the same server. Changing the deployed branch would be confusing, especially with large teams. Supporting multiple deployed branches at once requires additional servers and infrastructure management.

<Subheading>
  <Status type="err" /> Doesn't work offline
</Subheading>

Last but not least, **we need a stable internet connection** during development. This also means that if the development server is offline, we're unable to get any work done.

## Local setup

To overcome the limitations of a shared development server, we could run the entire API locally. Using a containerization method, like Docker, made this a lot easier, allowing us to have complex infrastructure running locally in just a few minutes.

<Figure background={"#fff"}>
  <Image
    src={img3}
    width="1818"
    height="870"
    alt="A User Interface connected to a local API"
  />
</Figure>

<Subheading>
  <Status type="ok" /> Works offline
</Subheading>

Since we're running everything locally, we **don't require an internet connection**.

<Subheading>
  <Status type="ok" /> Easily switch branches
</Subheading>

We have **complete control over the versioning system**, meaning that we can run any branch or tag. This allows us to test any work-in-progress feature, or to reproduce bugs using previous versions of the API.

<Subheading>
  <Status type="err" /> Cumbersome data sharing
</Subheading>

One limitation with running everything locally is that we **can't easily share the application state** with other team members. Sharing data requires either:

<ul>
  <li>
    exporting the database, sending it to our colleagues, and have them import
    it into their API;
  </li>
  <li>
    or tell them all the required steps to reach the desired application state.
  </li>
</ul>

<Subheading>
  <Status type="err" /> Additional maintenance effort
</Subheading>

Containerization indeed made this approach a whole lot easier, but with real-world applications, the **initial setup and subsequent updates are not always simple**:

<ul>
  <li>different operating systems usually require specific handling;</li>
  <li>
    working with certain 3rd party APIs, like payment gateways, might require
    mocking;
  </li>
  <li>
    not to mention that each team member will have to perform all the required
    database migrations, dependencies setup, and so on.
  </li>
</ul>

## Fake API

A third method we could use is to short-circuit the web API altogether, using some sort of proxy mock server or a local fake API. The one that I've used in the past with success is [json-server](https://github.com/typicode/json-server), but there are many other solutions available.

<Figure background={"#fff"}>
  <Image
    src={img4}
    width="1818"
    height="870"
    alt="A User Interface connected to a local Fake API"
  />
</Figure>

<Subheading>
  <Status type="ok" /> Easy data stubbing
</Subheading>

The biggest benefit of this approach is probably the **lack of effort required to stub specific data**. With the previous methods, we cannot directly control the endpoints' output. Instead, we have to bring the system to a certain state so that the endpoints respond with the desired output.

Having typed API requests helps a lot to ensure that we're including all the required data.

<Subheading>
  <Status type="err" /> Manual schema updates
</Subheading>

Probably the biggest drawback is that we'll have to **manually update the endpoints' response** whenever the real API changes, which incurs a maintenance cost.

Without a solid collaboration between the UI engineers responsible for the fake API and the maintainers of the real API, this could turn into a serios issue.

---

So, like any engineering problem, there is no silver bullet. None of the methods is perfect, but each of them shines in different situations:

- using a **fake API** works great for prototyping or during early development stages when we don't have a fully working web API;
- integrating with a **remote development server** proves very convenient, especially in teams where development is split between dedicated UI/Front-End and API/Back-End developers;
- having a **local setup of the API** provides a high degree of flexibility and control, useful in full-stack development, where developers work both on UI and API.
