import { BlogPost } from "../../../components/blog/blog_post";
import { Subheading } from "../../../components/blog/subheading";
import { Status } from "../../../components/blog/status";
import { Figure } from "../../../components/blog/figure";
import { Note } from "../../../components/blog/note";

import file_size from "./file-size.png";
import loading_time from "./loading-time.png";
import runtime_code from "./runtime-code.png";
import duplicated_styles from "./styles-shipped-twice.png";
import Image from "next/image";

import { meta } from "./meta";
export { meta } from "./meta";

export default ({ children }) => <BlogPost meta={meta}>{children}</BlogPost>;

With CSS-in-JS, we define the styles inside our JavaScript files. The browser, however, doesn't know how to deal with them in this form, so they need to reach the browser eventually in standard CSS syntax. There are two different, mutually exclusive methods to achieve this:

- [**Runtime stylesheets**](#runtime-stylesheets), used by the large majority of CSS-in-JS libraries, or;
- [**Static CSS extraction**](#static-css-extraction), used only by a handful of libraries.

This article will look at how these approaches work, debate their strong points and tradeoffs, and conclude when to [consider one or the other](#to-conclude).

## Runtime stylesheets

Regardless of what tools we use to build our applications or what specific CSS-in-JS library that implements runtime stylesheets we use, the style definitions will be included in the `.js` bundle, along with the components and the application logic.

```html
<!-- styles get bundled along with the components & app logic -->
<script src="bundle.js"></script>
```

<br />

Since browsers don't know how to handle the styles included in JavaScript files, some additional **runtime library** code is required. The runtime is included by default in the bundle at build time, and its purpose is to:

- read the styles from the JavaScript bundle;
- inject the styles into the DOM;
- update the styles whenever an event triggers a change.

```html
<!-- injects and updates styles to DOM -->
<!-- usually included in the bundle -->
<script src="library_runtime.js"></script>
```

<br />

Most CSS-in-JS libraries implement this method to output the CSS styles to the browser. In addition, there are various methods to inject and update the styles:

- Appending one or more `<style>` tag(s) usually in the document's `<head>` using the DOM API. This method is predominantly used in development as it provides better debuggability.
- Managing the stylesheets directly on the CSSOM using the [`CSSStyleSheet`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet) API. This is the preferred method for production builds, as it appears to be [more performant](https://youtu.be/75kmPj_iUOA?t=849) than manipulating `<style>` tags within the DOM.

<br />

Now, there are two worth mentioning issues with this method:

<Subheading>
  <Status type="err" /> Runtime library overhead
</Subheading>

As mentioned before, additional code needs to be shipped to the browser to inject and update the stylesheets at runtime. The size of this code could vary quite a lot between `1KB` and `18KB` minified.

It's essential to keep in mind that the runtime code is required with **CSR** (Client-Side Rendering) and **SSR** (Server-Side Rendering) as well.

<Figure
  background={"#fff"}
  caption="Runtime stylesheets require additional code to handle styles at runtime"
>
  <Image src={runtime_code} width="1650" height="708" />
</Figure>

<Subheading>
  <Status type="err" /> Duplicated styles with SSR
</Subheading>

When rendering on the server, CSS-in-JS libraries will also include the so-called [Critical CSS](https://github.com/andreipfeiffer/css-in-js/blob/main/README.md#-critical-css-extraction) along with the rendered HTML content. **Critical CSS** refers to all the styles required by the static HTML page generated by the server.

The caveat is that the **critical CSS styles will be shipped twice** to the browser: first with the HTML file and second with the JS bundle during re-hydration.

<Figure
  background={"#fff"}
  caption="Runtime stylesheets will bundle critical CSS twice during SSR"
>
  <Image src={duplicated_styles} width="1650" height="368" />
</Figure>

## Static CSS extraction

A different method, implemented only by a handful of CSS-in-JS libraries, is to extract all the styles defined in JS files and generate a regular `.css` file when building for production. This method allows us to include the styles as any regular CSS stylesheet in our document.

```html
<!-- styles are extracted as static .css files -->
<link rel="stylesheet" href="styles.css" />
```

<br />

The JavaScript bundle will only contain the components and the application logic, since the styles have been extracted in their own `.css` file. Also, there's no need for an additional runtime library since the browser can natively work with `.css` files.

```html
<!-- the bundle includes only the components and app logic -->
<script src="bundle.js"></script>
```

<Subheading>
  <Status type="ok" /> Smaller resources
</Subheading>

Without a doubt, extracting static CSS files will generate smaller bundles, thus shipping fewer bytes to the browsers. Also, with **SSR**, we don't require additional **Critical CSS** either, thus saving even more bytes.

<Figure
  background={"#fff"}
  caption="Static CSS extraction offers smaller builds compared to Runtime stylesheets during Server-Side Rendering"
>
  <Image src={file_size} width="1650" height="553" />
</Figure>

<br />

Static CSS extraction offers zero-runtime cost. The end result is similar to using non-CSS-in-JS solutions like plain CSS, pre-processors, or CSS modules, sharing all the benefits and downsides of CSS stylesheets.

## But what about time?

**Size** is only one of the metrics that we can analyze, **time** being another relevant one. So, there's an important question that we need to ask:

> Does a smaller page size implies faster loading times as well?

To answer this question, we'll have to look at the HTTP requests that a browser will send to the server to fetch the page's resources. So, let's see how a loading waterfall chart looks for a typical but minimal web page, using both methods mentioned above.

<Figure
  background={"#fff"}
  caption="Even though runtime stylesheets are usually larger in file size, they could load faster than Static CSS extraction"
>
  <Image src={loading_time} width="1650" height="850" />
</Figure>

<br />

Since **static CSS extraction** implies a regular `.css` file to be included as any other stylesheet in the document's `<head>`, the loading waterfall is slightly different:

1. the browser will download and parse the HTML file;
2. during parsing, the browser will encounter the .css file reference, so it will make another request to fetch the `styles.css` file, an action that **blocks rendering**;
3. after downloading and parsing the `.css` file, the browser can continue downloading other resources included in the `<body>`.

Presuming that we include the `.js` files at the end of the document's `<body>`, the browser cannot start painting the page until the entire `.css` file is downloaded and parsed. So, static CSS introduces a [render-blocking CSS resource](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css).

<br />

In the case of **runtime stylesheets**, the following steps will occur:

1. the browser will download and parse the HTML file;
2. then, it will download the JavaScript files, namely `bundle.js` and `library_runtime.js`.

If we include the `.js` files at the end of the document's `<body>`, and there are no other resources included in the `<head>` section, then the browser can **start painting** the page on the screen as soon as the HTML document is parsed.

<Subheading>
  <Status type="ok" /> Faster Paint Time with Runtime Stylesheets
</Subheading>

Excluding any other optimization techniques, the runtime stylesheets offer faster [First Paint metrics](https://developer.mozilla.org/en-US/docs/Glossary/First_paint), because it doesn't require an additional HTTP request for the external CSS file.

<Note title="Notes">
  <p>It's worth mentioning that{" "}
<a href="https://web.dev/interactive/" target="_blank">
  TTI (Time to Interactive)
</a>{" "}
is nondeterministic, whether it's faster or slower, using one of the two
methods. The involved variables are too many to draw a definite conclusion.</p>

<p>
  The example is oversimplified. Many details were left out for the sake of
  simplicity.
</p>

</Note>

## To conclude

Without a doubt, both runtime stylesheets and static CSS extraction are valid options to consider when choosing a CSS-in-JS library. But I feel that they naturally suit different purposes.

<br />

**Runtime stylesheets** seem to fit better with highly dynamic solutions such as [Single Page Applications (SPAs)](https://en.wikipedia.org/wiki/Single-page_application), which usually make use of [Client-Side Rendering (CSR)](https://developers.google.com/web/updates/2019/02/rendering-on-the-web#csr):

- we don't need Critical CSS extraction, thus avoiding shipping part of our styles twice to the browser;
- they benefit from faster Paint Times to show loading indicators because the data is usually fetched Client-Side in such applications.

<br />

**Static CSS extraction**, on the other hand, seems to fit better with more static solutions such as [Static Rendering (SSG)](https://developers.google.com/web/updates/2019/02/rendering-on-the-web#static-rendering) and [Server-Side Rendering (SSR)](https://developers.google.com/web/updates/2019/02/rendering-on-the-web#server-rendering):

- fewer bytes get shipped to the users because there's no overhead involved;
- changing JavaScript code while leaving CSS styles untouched will benefit from better caching.

---

It's important to understand that the above conclusions are only general guidelines. For example, some applications require hybrid rendering, combining SSR/CSR/SSG. Also, there are other considerations to think about, especially with large applications:

- Do we want to optimize for first-time users or returning visitors?
- How often do we release new builds, thus invalidating the cache?
- What do we change more often: styles or component/application code?
